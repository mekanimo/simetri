<!DOCTYPE html>

<html lang="en" data-content_root="../../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>simetri.lace.lace &#8212; simetri.graphics 0.0.5 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=5ecbeea2" />
    <link rel="stylesheet" type="text/css" href="../../../_static/basic.css?v=686e5160" />
    <link rel="stylesheet" type="text/css" href="../../../_static/alabaster.css?v=27fed22d" />
    <script src="../../../_static/documentation_options.js?v=282f96c0"></script>
    <script src="../../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for simetri.lace.lace</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Simetri library&#39;s interlace objects.&quot;&quot;&quot;</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">itertools</span><span class="w"> </span><span class="kn">import</span> <span class="n">combinations</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Iterator</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Union</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">collections</span><span class="w"> </span><span class="kn">import</span> <span class="n">OrderedDict</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">networkx</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">nx</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="kn">import</span> <span class="n">isclose</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">..graphics.shape</span><span class="w"> </span><span class="kn">import</span> <span class="n">Shape</span><span class="p">,</span> <span class="n">custom_attributes</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">..graphics.batch</span><span class="w"> </span><span class="kn">import</span> <span class="n">Batch</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">..colors</span><span class="w"> </span><span class="kn">import</span> <span class="n">colors</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">..geometry.geometry</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">connected_pairs</span><span class="p">,</span>
    <span class="n">polygon_area</span><span class="p">,</span>
    <span class="n">distance</span><span class="p">,</span>
    <span class="n">double_offset_polygons</span><span class="p">,</span>
    <span class="n">get_polygons</span><span class="p">,</span>
    <span class="n">double_offset_polylines</span><span class="p">,</span>
    <span class="n">intersection2</span><span class="p">,</span>
    <span class="n">right_handed</span><span class="p">,</span>
    <span class="n">polygon_cg</span><span class="p">,</span>
    <span class="n">round_point</span><span class="p">,</span>
    <span class="n">offset_polygon</span><span class="p">,</span>
    <span class="n">offset_polygon_points</span><span class="p">,</span>
    <span class="n">convex_hull</span><span class="p">,</span>
    <span class="n">close_points2</span><span class="p">,</span>
    <span class="n">polygon_center</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">..helpers.graph</span><span class="w"> </span><span class="kn">import</span> <span class="n">get_cycles</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">..graphics.common</span><span class="w"> </span><span class="kn">import</span> <span class="n">get_defaults</span><span class="p">,</span> <span class="n">common_properties</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">..graphics.all_enums</span><span class="w"> </span><span class="kn">import</span> <span class="n">Types</span><span class="p">,</span> <span class="n">Connection</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">..canvas.style_map</span><span class="w"> </span><span class="kn">import</span> <span class="n">shape_style_map</span><span class="p">,</span> <span class="n">ShapeStyle</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">..canvas.canvas</span><span class="w"> </span><span class="kn">import</span> <span class="n">Canvas</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">..settings.settings</span><span class="w"> </span><span class="kn">import</span> <span class="n">defaults</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">..helpers.utilities</span><span class="w"> </span><span class="kn">import</span> <span class="n">flatten</span><span class="p">,</span> <span class="n">group_into_bins</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">..helpers.validation</span><span class="w"> </span><span class="kn">import</span> <span class="n">validate_args</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_set_style</span><span class="p">(</span><span class="n">obj</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="n">attribs</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">attribs</span><span class="p">:</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">defaults</span><span class="p">[</span><span class="s2">&quot;style&quot;</span><span class="p">],</span> <span class="n">attr</span><span class="p">))</span>


<span class="n">array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span>


<span class="c1"># Lace (Batch)</span>
<span class="c1">#     parallel_polyline_list (list)</span>
<span class="c1">#         parallel_polyline1 (ParallelPolyline-Batch-PARALLELPOLYLINE)</span>
<span class="c1">#             polyline_list (list)</span>
<span class="c1">#             |    polyline1 (Polyline-Shape)</span>
<span class="c1">#             |        divisions (list)</span>
<span class="c1">#             |            division1 (Division-Shape)</span>
<span class="c1">#             |                p1 (tuple)</span>
<span class="c1">#             |                p2 (tuple)</span>
<span class="c1">#             |                sections (list)</span>
<span class="c1">#             |                    section1(Section-Shape)</span>
<span class="c1">#             |                        p1 (tuple)</span>
<span class="c1">#             |                        p2</span>
<span class="c1">#             |                        is_overlap (bool)</span>
<span class="c1">#             |                        overlap (Overlap-Batch)</span>
<span class="c1">#             |overlaps (list)</span>
<span class="c1">#             |   overlap1(Overlap-Batch)</span>
<span class="c1">#             |       divisions (list)</span>
<span class="c1">#             |           division1(Division-Shape)</span>
<span class="c1">#             |               p1 (tuple)</span>
<span class="c1">#             |               p2 (tuple)</span>
<span class="c1">#             |               sections (list)</span>
<span class="c1">#             |                   section1(Section-Shape)</span>
<span class="c1">#             |                       start (Intersection-Shape)</span>
<span class="c1">#             |                       end (Intersection-Shape)</span>
<span class="c1">#             |                       overlap</span>
<span class="c1">#             |</span>
<span class="c1">#             |</span>
<span class="c1">#             |fragments</span>
<span class="c1">#                 fragment1(Shape)</span>
<span class="c1">#                     divisions</span>
<span class="c1">#                         division1(Shape)</span>
<span class="c1">#                             p1</span>
<span class="c1">#                             p2</span>
<span class="c1">#                             sections</span>
<span class="c1">#                                 section1</span>

<span class="c1">#             plaits (list)</span>
<span class="c1">#                 plait1 (Plait-Shape)</span>

<span class="c1"># All objects in this module is a subclass of the Shape or Batch class.</span>
<span class="c1"># They are used to compute the interlacing patterns.</span>

<span class="c1">#  Example of a Lace object.</span>

<span class="c1">#     /\</span>
<span class="c1">#    //\\ /\</span>
<span class="c1">#   //  \//\\</span>
<span class="c1">#  //   /\\ \\</span>
<span class="c1"># //   // \\ \\</span>
<span class="c1"># \\   \\ //  //</span>
<span class="c1">#  \\   \//  //</span>
<span class="c1">#   \\  //\\//</span>
<span class="c1">#    \\//  \/</span>
<span class="c1">#     \/</span>

<span class="c1"># Example of a ParallelPolylines object. The lace object above has two</span>
<span class="c1"># ParallelPolylines objects. Main polylines are not shown, they are</span>
<span class="c1"># located in the middle of the offset polylines.</span>

<span class="c1">#         /\</span>
<span class="c1">#        //\\</span>
<span class="c1">#       //  \\</span>
<span class="c1">#      //    \\</span>
<span class="c1">#      \\    //</span>
<span class="c1">#       \\  //</span>
<span class="c1">#        \\//</span>
<span class="c1">#         \/</span>

<span class="c1"># Example of a Fragment object.</span>
<span class="c1"># They are polygons or polylines.</span>
<span class="c1"># The lace object above has three fragments.</span>
<span class="c1"># This is the middle fragment.</span>

<span class="c1">#         /\</span>
<span class="c1">#        /  \</span>
<span class="c1">#        \  /</span>
<span class="c1">#         \/</span>

<span class="c1"># Example of a plait object. They are polylines.</span>
<span class="c1"># Used for drawing under/over interlacing.</span>

<span class="c1">#         /\</span>
<span class="c1">#         \ \</span>
<span class="c1">#          \ \</span>
<span class="c1">#          / /</span>
<span class="c1">#         / /</span>
<span class="c1">#         \/</span>

<span class="c1"># Example of an Overlap object.</span>
<span class="c1"># The lace object above has two overlap regions.</span>

<span class="c1">#         /\</span>
<span class="c1">#         \/</span>

<span class="c1"># Example of a Polyline object.</span>

<span class="c1">#          /\</span>
<span class="c1">#         /  \</span>
<span class="c1">#        /    \</span>
<span class="c1">#       /      \</span>
<span class="c1">#      /        \</span>
<span class="c1">#      \        /</span>
<span class="c1">#       \      /</span>
<span class="c1">#        \    /</span>
<span class="c1">#         \  /</span>
<span class="c1">#          \/</span>

<span class="c1"># Example of an Division object.</span>
<span class="c1"># Each polyline is made up of one or more &quot;Division&quot; objects.</span>
<span class="c1"># Each division is divided into sections</span>
<span class="c1"># Maybe &quot;Divisions&quot; would be a better name instead of &quot;Division&quot;?</span>
<span class="c1">#            *</span>
<span class="c1">#             \</span>
<span class="c1">#              *</span>
<span class="c1">#               \</span>
<span class="c1">#                *</span>
<span class="c1">#                 \</span>
<span class="c1">#                  *</span>
<span class="c1"># Example of a Section object.</span>
<span class="c1"># Each division is made up of one or more sections.</span>
<span class="c1"># Sections have intersection points at their ends.</span>
<span class="c1">#                 *</span>
<span class="c1">#                  \</span>
<span class="c1">#                   *</span>
<span class="c1"># * intersections have a point, division1, division2 attributes.</span>
<span class="c1"># &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Intersection">
<a class="viewcode-back" href="../../../simetri.lace.html#simetri.lace.lace.Intersection">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Intersection</span><span class="p">(</span><span class="n">Shape</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Intersection of two divisions. They are at the endpoints of Section</span>
<span class="sd">    objects. A division can have multiple sections and multiple</span>
<span class="sd">    intersections. They can be located at the end of a division.</span>

<span class="sd">    Args:</span>
<span class="sd">        point (tuple): (x, y) coordinates of the intersection point.</span>
<span class="sd">        division1 (Division): First division.</span>
<span class="sd">        division2 (Division, optional): Second division. Defaults to None.</span>
<span class="sd">        endpoint (bool, optional): If the intersection is at the end of a division, then endpoint is True. Defaults to False.</span>
<span class="sd">        **kwargs: Additional attributes for cosmetic/drawing purposes.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">point</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">,</span> <span class="n">division1</span><span class="p">:</span> <span class="s2">&quot;Division&quot;</span><span class="p">,</span> <span class="n">division2</span><span class="p">:</span> <span class="s2">&quot;Division&quot;</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">endpoint</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">([</span><span class="n">point</span><span class="p">],</span> <span class="n">xform_matrix</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">subtype</span><span class="o">=</span><span class="n">Types</span><span class="o">.</span><span class="n">INTERSECTION</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_point</span> <span class="o">=</span> <span class="n">point</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">division1</span> <span class="o">=</span> <span class="n">division1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">division2</span> <span class="o">=</span> <span class="n">division2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">overlap</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">endpoint</span> <span class="o">=</span> <span class="n">endpoint</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">division</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># used for fragment divisions&#39; DCEL structure</span>

        <span class="n">common_properties</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">id_only</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xform_matrix</span><span class="p">:</span> <span class="n">array</span><span class="p">,</span> <span class="n">reps</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Update the transformation matrix of the intersection.</span>

<span class="sd">        Args:</span>
<span class="sd">            xform_matrix (array): Transformation matrix.</span>
<span class="sd">            reps (int, optional): Number of repetitions. Defaults to 0.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Any: Updated intersection or list of updated intersections.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">reps</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">xform_matrix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xform_matrix</span> <span class="o">@</span> <span class="n">xform_matrix</span>
            <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">reps</span><span class="p">):</span>
                <span class="n">shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">shape</span><span class="o">.</span><span class="n">_update</span><span class="p">(</span><span class="n">xform_matrix</span><span class="p">)</span>
                <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">res</span>

<div class="viewcode-block" id="Intersection.copy">
<a class="viewcode-back" href="../../../simetri.lace.html#simetri.lace.lace.Intersection.copy">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a copy of the intersection.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Intersection: A copy of the intersection.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">intersection</span> <span class="o">=</span> <span class="n">Intersection</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">point</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">division1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">division2</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">attrib</span> <span class="ow">in</span> <span class="n">shape_style_map</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">intersection</span><span class="p">,</span> <span class="n">attrib</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attrib</span><span class="p">))</span>
        <span class="n">custom_attribs</span> <span class="o">=</span> <span class="n">custom_attributes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">attrib</span> <span class="ow">in</span> <span class="n">custom_attribs</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">intersection</span><span class="p">,</span> <span class="n">attrib</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attrib</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">intersection</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">point</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the intersection point.</span>

<span class="sd">        Returns:</span>
<span class="sd">            list: Intersection point coordinates.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">_point</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">])</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">xform_matrix</span><span class="p">)[:</span><span class="mi">2</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;String representation of the intersection.</span>

<span class="sd">        Returns:</span>
<span class="sd">            str: String representation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Intersection(</span><span class="si">{</span><span class="p">[</span><span class="nb">round</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">defaults</span><span class="p">[</span><span class="s1">&#39;n_round&#39;</span><span class="p">])</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="bp">self</span><span class="o">.</span><span class="n">point</span><span class="p">]</span><span class="si">}</span><span class="s2">, &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">list</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">division1</span><span class="p">,</span><span class="w"> </span><span class="bp">self</span><span class="o">.</span><span class="n">division2</span><span class="p">]))</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;String representation of the intersection.</span>

<span class="sd">        Returns:</span>
<span class="sd">            str: String representation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Check if two intersections are equal.</span>

<span class="sd">        Args:</span>
<span class="sd">            other (Intersection): Another intersection.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: True if equal, False otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">close_points2</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">point</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">point</span><span class="p">,</span> <span class="n">dist2</span><span class="o">=</span><span class="n">defaults</span><span class="p">[</span><span class="s2">&quot;dist_tol&quot;</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span></div>



<div class="viewcode-block" id="Partition">
<a class="viewcode-back" href="../../../simetri.lace.html#simetri.lace.lace.Partition">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Partition</span><span class="p">(</span><span class="n">Shape</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;These are the polygons of the non-interlaced geometry.</span>
<span class="sd">    Fragments and partitions are scaled versions of each other.</span>

<span class="sd">    Args:</span>
<span class="sd">        points (list): List of points defining the partition.</span>
<span class="sd">        **kwargs: Additional attributes for cosmetic/drawing purposes.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">subtype</span> <span class="o">=</span> <span class="n">Types</span><span class="o">.</span><span class="n">PART</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">area</span> <span class="o">=</span> <span class="n">polygon_area</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">CG</span> <span class="o">=</span> <span class="n">polygon_cg</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">)</span>
        <span class="n">common_properties</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;String representation of the partition.</span>

<span class="sd">        Returns:</span>
<span class="sd">            str: String representation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;Part(</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="si">}</span><span class="s2">)&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;String representation of the partition.</span>

<span class="sd">        Returns:</span>
<span class="sd">            str: String representation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__str__</span><span class="p">()</span></div>



<div class="viewcode-block" id="Fragment">
<a class="viewcode-back" href="../../../simetri.lace.html#simetri.lace.lace.Fragment">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Fragment</span><span class="p">(</span><span class="n">Shape</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A Fragment is a collection of section objects that are connected</span>
<span class="sd">    to each other. These sections are already defined. They belong to</span>
<span class="sd">    the polyline objects in a lace. Fragments can be open or closed.</span>
<span class="sd">    They are created by the lace object.</span>

<span class="sd">    Args:</span>
<span class="sd">        points (list): List of points defining the fragment.</span>
<span class="sd">        **kwargs: Additional attributes for cosmetic/drawing purposes.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">subtype</span> <span class="o">=</span> <span class="n">Types</span><span class="o">.</span><span class="n">FRAGMENT</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">area</span> <span class="o">=</span> <span class="n">polygon_area</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sections</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">intersections</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">inner_lines</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_divisions</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">CG</span> <span class="o">=</span> <span class="n">polygon_cg</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">)</span>
        <span class="n">common_properties</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;String representation of the fragment.</span>

<span class="sd">        Returns:</span>
<span class="sd">            str: String representation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;Fragment(</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="si">}</span><span class="s2">)&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;String representation of the fragment.</span>

<span class="sd">        Returns:</span>
<span class="sd">            str: String representation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__str__</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">divisions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the divisions of the fragment.</span>

<span class="sd">        Returns:</span>
<span class="sd">            list: List of divisions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_divisions</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">center</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the center of the fragment.</span>

<span class="sd">        Returns:</span>
<span class="sd">            list: Center coordinates.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">CG</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_set_divisions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dist_tol</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">dist_tol</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dist_tol</span> <span class="o">=</span> <span class="n">defaults</span><span class="p">[</span><span class="s2">&quot;dist_tol&quot;</span><span class="p">]</span>
        <span class="n">dist_tol2</span> <span class="o">=</span> <span class="n">dist_tol</span> <span class="o">*</span> <span class="n">dist_tol</span>  <span class="c1"># squared distance tolerance</span>
        <span class="n">d_points__section</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">section</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sections</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">section</span><span class="o">.</span><span class="n">start</span><span class="o">.</span><span class="n">point</span>
            <span class="n">end</span> <span class="o">=</span> <span class="n">section</span><span class="o">.</span><span class="n">end</span><span class="o">.</span><span class="n">point</span>
            <span class="n">start</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">start</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">2</span><span class="p">),</span> <span class="nb">round</span><span class="p">(</span><span class="n">start</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">end</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">end</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">2</span><span class="p">),</span> <span class="nb">round</span><span class="p">(</span><span class="n">end</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">d_points__section</span><span class="p">[(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)]</span> <span class="o">=</span> <span class="n">section</span>
            <span class="n">d_points__section</span><span class="p">[(</span><span class="n">end</span><span class="p">,</span> <span class="n">start</span><span class="p">)]</span> <span class="o">=</span> <span class="n">section</span>

        <span class="n">coord_pairs</span> <span class="o">=</span> <span class="n">connected_pairs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_divisions</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="n">coord_pairs</span><span class="p">:</span>
            <span class="n">x1</span><span class="p">,</span> <span class="n">y1</span> <span class="o">=</span> <span class="n">round_point</span><span class="p">(</span><span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">x2</span><span class="p">,</span> <span class="n">y2</span> <span class="o">=</span> <span class="n">round_point</span><span class="p">(</span><span class="n">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">division</span> <span class="o">=</span> <span class="n">Division</span><span class="p">((</span><span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">),</span> <span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">y2</span><span class="p">))</span>
            <span class="n">division</span><span class="o">.</span><span class="n">section</span> <span class="o">=</span> <span class="n">d_points__section</span><span class="p">[((</span><span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">),</span> <span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">y2</span><span class="p">))]</span>
            <span class="n">division</span><span class="o">.</span><span class="n">fragment</span> <span class="o">=</span> <span class="bp">self</span>
            <span class="n">start_point</span> <span class="o">=</span> <span class="n">round_point</span><span class="p">(</span><span class="n">division</span><span class="o">.</span><span class="n">section</span><span class="o">.</span><span class="n">start</span><span class="o">.</span><span class="n">point</span><span class="p">)</span>
            <span class="n">end_point</span> <span class="o">=</span> <span class="n">round_point</span><span class="p">(</span><span class="n">division</span><span class="o">.</span><span class="n">section</span><span class="o">.</span><span class="n">end</span><span class="o">.</span><span class="n">point</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">close_points2</span><span class="p">(</span><span class="n">start_point</span><span class="p">,</span> <span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">),</span> <span class="n">dist2</span><span class="o">=</span><span class="n">dist_tol2</span><span class="p">):</span>
                <span class="n">division</span><span class="o">.</span><span class="n">intersections</span> <span class="o">=</span> <span class="p">[</span><span class="n">division</span><span class="o">.</span><span class="n">section</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">division</span><span class="o">.</span><span class="n">section</span><span class="o">.</span><span class="n">end</span><span class="p">]</span>
                <span class="n">division</span><span class="o">.</span><span class="n">section</span><span class="o">.</span><span class="n">start</span><span class="o">.</span><span class="n">division</span> <span class="o">=</span> <span class="n">division</span>
            <span class="k">elif</span> <span class="n">close_points2</span><span class="p">(</span><span class="n">end_point</span><span class="p">,</span> <span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">),</span> <span class="n">dist2</span><span class="o">=</span><span class="n">dist_tol2</span><span class="p">):</span>
                <span class="n">division</span><span class="o">.</span><span class="n">intersections</span> <span class="o">=</span> <span class="p">[</span><span class="n">division</span><span class="o">.</span><span class="n">section</span><span class="o">.</span><span class="n">end</span><span class="p">,</span> <span class="n">division</span><span class="o">.</span><span class="n">section</span><span class="o">.</span><span class="n">start</span><span class="p">]</span>
                <span class="n">division</span><span class="o">.</span><span class="n">section</span><span class="o">.</span><span class="n">end</span><span class="o">.</span><span class="n">division</span> <span class="o">=</span> <span class="n">division</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Division does not match section&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_divisions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">division</span><span class="p">)</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_divisions</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">division</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_divisions</span><span class="p">):</span>
            <span class="n">division</span><span class="o">.</span><span class="n">prev</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_divisions</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">division</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_divisions</span><span class="p">[(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">n</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_set_twin_divisions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">division</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">divisions</span><span class="p">:</span>
            <span class="n">section</span> <span class="o">=</span> <span class="n">division</span><span class="o">.</span><span class="n">section</span>
            <span class="k">if</span> <span class="n">section</span><span class="o">.</span><span class="n">twin</span> <span class="ow">and</span> <span class="n">section</span><span class="o">.</span><span class="n">twin</span><span class="o">.</span><span class="n">fragment</span><span class="p">:</span>
                <span class="n">twin_fragment</span> <span class="o">=</span> <span class="n">section</span><span class="o">.</span><span class="n">twin</span><span class="o">.</span><span class="n">fragment</span>
                <span class="n">distances</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">division2</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">twin_fragment</span><span class="o">.</span><span class="n">divisions</span><span class="p">):</span>
                    <span class="n">dist</span> <span class="o">=</span> <span class="n">distance</span><span class="p">(</span>
                        <span class="n">division</span><span class="o">.</span><span class="n">section</span><span class="o">.</span><span class="n">mid_point</span><span class="p">,</span> <span class="n">division2</span><span class="o">.</span><span class="n">section</span><span class="o">.</span><span class="n">mid_point</span>
                    <span class="p">)</span>
                    <span class="n">distances</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">dist</span><span class="p">,</span> <span class="n">division2</span><span class="p">))</span>
                <span class="n">distances</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">division</span><span class="o">.</span><span class="n">twin</span> <span class="o">=</span> <span class="n">distances</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span></div>



<div class="viewcode-block" id="Section">
<a class="viewcode-back" href="../../../simetri.lace.html#simetri.lace.lace.Section">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Section</span><span class="p">(</span><span class="n">Shape</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A section is a line segment between two intersections.</span>
<span class="sd">    A division can have multiple sections. Sections are used to</span>
<span class="sd">    draw the over/under plaits.</span>

<span class="sd">    Args:</span>
<span class="sd">        start (Intersection): Start intersection.</span>
<span class="sd">        end (Intersection): End intersection.</span>
<span class="sd">        is_overlap (bool, optional): If the section is an overlap. Defaults to False.</span>
<span class="sd">        overlap (Overlap, optional): Overlap object. Defaults to None.</span>
<span class="sd">        is_over (bool, optional): If the section is over. Defaults to False.</span>
<span class="sd">        twin (Section, optional): Twin section. Defaults to None.</span>
<span class="sd">        fragment (Fragment, optional): Fragment object. Defaults to None.</span>
<span class="sd">        **kwargs: Additional attributes for cosmetic/drawing purposes.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">start</span><span class="p">:</span> <span class="n">Intersection</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">end</span><span class="p">:</span> <span class="n">Intersection</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">is_overlap</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">overlap</span><span class="p">:</span> <span class="s2">&quot;Overlap&quot;</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">is_over</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">twin</span><span class="p">:</span> <span class="s2">&quot;Section&quot;</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">fragment</span><span class="p">:</span> <span class="s2">&quot;Fragment&quot;</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">([</span><span class="n">start</span><span class="o">.</span><span class="n">point</span><span class="p">,</span> <span class="n">end</span><span class="o">.</span><span class="n">point</span><span class="p">],</span> <span class="n">subtype</span><span class="o">=</span><span class="n">Types</span><span class="o">.</span><span class="n">SECTION</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">start</span> <span class="o">=</span> <span class="n">start</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">end</span> <span class="o">=</span> <span class="n">end</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_overlap</span> <span class="o">=</span> <span class="n">is_overlap</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">overlap</span> <span class="o">=</span> <span class="n">overlap</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_over</span> <span class="o">=</span> <span class="n">is_over</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">twin</span> <span class="o">=</span> <span class="n">twin</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fragment</span> <span class="o">=</span> <span class="n">fragment</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">([</span><span class="n">start</span><span class="o">.</span><span class="n">point</span><span class="p">,</span> <span class="n">end</span><span class="o">.</span><span class="n">point</span><span class="p">],</span> <span class="n">subtype</span><span class="o">=</span><span class="n">Types</span><span class="o">.</span><span class="n">SECTION</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">length</span> <span class="o">=</span> <span class="n">distance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">start</span><span class="o">.</span><span class="n">point</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">end</span><span class="o">.</span><span class="n">point</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mid_point</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">start</span><span class="o">.</span><span class="n">point</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">end</span><span class="o">.</span><span class="n">point</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">start</span><span class="o">.</span><span class="n">point</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">end</span><span class="o">.</span><span class="n">point</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span>
        <span class="p">]</span>
        <span class="n">common_properties</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

<div class="viewcode-block" id="Section.copy">
<a class="viewcode-back" href="../../../simetri.lace.html#simetri.lace.lace.Section.copy">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a copy of the section.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Section: A copy of the section.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">overlap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">overlap</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">overlap</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="n">start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">start</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">end</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">section</span> <span class="o">=</span> <span class="n">Section</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_overlap</span><span class="p">,</span> <span class="n">overlap</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_over</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">section</span></div>


<div class="viewcode-block" id="Section.end_point">
<a class="viewcode-back" href="../../../simetri.lace.html#simetri.lace.lace.Section.end_point">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">end_point</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the end point of the section.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Intersection: End intersection.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">start</span><span class="o">.</span><span class="n">endpoint</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">start</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">end</span><span class="o">.</span><span class="n">endpoint</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">end</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="n">res</span></div>


    <span class="k">def</span><span class="w"> </span><span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;String representation of the section.</span>

<span class="sd">        Returns:</span>
<span class="sd">            str: String representation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;Section(</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">start</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">end</span><span class="si">}</span><span class="s2">)&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;String representation of the section.</span>

<span class="sd">        Returns:</span>
<span class="sd">            str: String representation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__str__</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_endpoint</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return True if the section is an endpoint.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: True if endpoint, False otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">start</span><span class="o">.</span><span class="n">endpoint</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">end</span><span class="o">.</span><span class="n">endpoint</span></div>



<div class="viewcode-block" id="Overlap">
<a class="viewcode-back" href="../../../simetri.lace.html#simetri.lace.lace.Overlap">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Overlap</span><span class="p">(</span><span class="n">Batch</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;An overlap is a collection of four connected sections.</span>

<span class="sd">    Args:</span>
<span class="sd">        intersections (list[Intersection], optional): List of intersections. Defaults to None.</span>
<span class="sd">        sections (list[Section], optional): List of sections. Defaults to None.</span>
<span class="sd">        visited (bool, optional): If the overlap is visited. Defaults to False.</span>
<span class="sd">        drawable (bool, optional): If the overlap is drawable. Defaults to True.</span>
<span class="sd">        **kwargs: Additional attributes for cosmetic/drawing purposes.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">intersections</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Intersection</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">sections</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Section</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">visited</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">drawable</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">intersections</span> <span class="o">=</span> <span class="n">intersections</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sections</span> <span class="o">=</span> <span class="n">sections</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">sections</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">subtype</span> <span class="o">=</span> <span class="n">Types</span><span class="o">.</span><span class="n">OVERLAP</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">visited</span> <span class="o">=</span> <span class="n">visited</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">drawable</span> <span class="o">=</span> <span class="n">drawable</span>
        <span class="n">common_properties</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;String representation of the overlap.</span>

<span class="sd">        Returns:</span>
<span class="sd">            str: String representation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;Overlap(</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="si">}</span><span class="s2">)&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;String representation of the overlap.</span>

<span class="sd">        Returns:</span>
<span class="sd">            str: String representation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;Overlap(</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="si">}</span><span class="s2">)&quot;</span></div>



<div class="viewcode-block" id="Division">
<a class="viewcode-back" href="../../../simetri.lace.html#simetri.lace.lace.Division">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Division</span><span class="p">(</span><span class="n">Shape</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A division is a line segment between two intersections.</span>

<span class="sd">    Args:</span>
<span class="sd">        p1 (tuple): Start point.</span>
<span class="sd">        p2 (tuple): End point.</span>
<span class="sd">        xform_matrix (array, optional): Transformation matrix. Defaults to None.</span>
<span class="sd">        **kwargs: Additional attributes for cosmetic/drawing purposes.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">xform_matrix</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">([</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">],</span> <span class="n">subtype</span><span class="o">=</span><span class="n">Types</span><span class="o">.</span><span class="n">DIVISION</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">p1</span> <span class="o">=</span> <span class="n">p1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">p2</span> <span class="o">=</span> <span class="n">p2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">intersections</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">twin</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># used for fragment divisions only</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">section</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># used for fragment divisions only</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fragment</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># used for fragment divisions only</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># used for fragment divisions only</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prev</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># used for fragment divisions only</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sections</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="p">[</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">],</span> <span class="n">subtype</span><span class="o">=</span><span class="n">Types</span><span class="o">.</span><span class="n">DIVISION</span><span class="p">,</span> <span class="n">xform_matrix</span><span class="o">=</span><span class="n">xform_matrix</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>
        <span class="n">common_properties</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xform_matrix</span><span class="p">,</span> <span class="n">reps</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Update the transformation matrix of the division.</span>

<span class="sd">        Args:</span>
<span class="sd">            xform_matrix (array): Transformation matrix.</span>
<span class="sd">            reps (int, optional): Number of repetitions. Defaults to 0.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Any: Updated division or list of updated divisions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">reps</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">xform_matrix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xform_matrix</span> <span class="o">@</span> <span class="n">xform_matrix</span>
            <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">reps</span><span class="p">):</span>
                <span class="n">shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">shape</span><span class="o">.</span><span class="n">_update</span><span class="p">(</span><span class="n">xform_matrix</span><span class="p">)</span>
                <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">res</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;String representation of the division.</span>

<span class="sd">        Returns:</span>
<span class="sd">            str: String representation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Division((</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">p1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">p1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">), &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;(</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">p2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">p2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">))&quot;</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;String representation of the division.</span>

<span class="sd">        Returns:</span>
<span class="sd">            str: String representation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Division((</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">p1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">p1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">), &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;(</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">p2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">p2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">))&quot;</span>
        <span class="p">)</span>

<div class="viewcode-block" id="Division.copy">
<a class="viewcode-back" href="../../../simetri.lace.html#simetri.lace.lace.Division.copy">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">copy</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">section</span><span class="p">:</span> <span class="n">Section</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">twin</span><span class="p">:</span> <span class="n">Section</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a copy of the division.</span>

<span class="sd">        Args:</span>
<span class="sd">            section (Section, optional): Section object. Defaults to None.</span>
<span class="sd">            twin (Section, optional): Twin section. Defaults to None.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Division: A copy of the division.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">division</span> <span class="o">=</span> <span class="n">Division</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">p1</span><span class="p">[:],</span> <span class="bp">self</span><span class="o">.</span><span class="n">p2</span><span class="p">[:],</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xform_matrix</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">attrib</span> <span class="ow">in</span> <span class="n">shape_style_map</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">division</span><span class="p">,</span> <span class="n">attrib</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attrib</span><span class="p">))</span>
        <span class="n">division</span><span class="o">.</span><span class="n">twin</span> <span class="o">=</span> <span class="n">twin</span>
        <span class="n">division</span><span class="o">.</span><span class="n">section</span> <span class="o">=</span> <span class="n">section</span>
        <span class="n">division</span><span class="o">.</span><span class="n">fragment</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fragment</span>
        <span class="n">division</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">next</span>
        <span class="n">division</span><span class="o">.</span><span class="n">prev</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prev</span>
        <span class="n">division</span><span class="o">.</span><span class="n">sections</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sections</span><span class="p">]</span>
        <span class="n">custom_attributes_</span> <span class="o">=</span> <span class="n">custom_attributes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">attrib</span> <span class="ow">in</span> <span class="n">custom_attributes_</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">division</span><span class="p">,</span> <span class="n">attrib</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attrib</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">division</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_merged_sections</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Merge sections of the division.</span>

<span class="sd">        Returns:</span>
<span class="sd">            list: List of merged sections.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">chains</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">chain</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">intersections</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="n">sections</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sections</span><span class="p">[:]</span>
        <span class="k">for</span> <span class="n">section</span> <span class="ow">in</span> <span class="n">sections</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">section</span><span class="o">.</span><span class="n">is_over</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">section</span><span class="o">.</span><span class="n">start</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">chain</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">id</span><span class="p">:</span>
                    <span class="n">chain</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">section</span><span class="o">.</span><span class="n">end</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">chains</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">chain</span><span class="p">)</span>
                    <span class="n">chain</span> <span class="o">=</span> <span class="p">[</span><span class="n">section</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">section</span><span class="o">.</span><span class="n">end</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">chain</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">chains</span><span class="p">:</span>
            <span class="n">chains</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">chain</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">chains</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_sort_intersections</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Sort intersections of the division.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">intersections</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">distance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">p1</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">point</span><span class="p">))</span>

<div class="viewcode-block" id="Division.is_connected">
<a class="viewcode-back" href="../../../simetri.lace.html#simetri.lace.lace.Division.is_connected">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_connected</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s2">&quot;Division&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return True if the division is connected to another division.</span>

<span class="sd">        Args:</span>
<span class="sd">            other (Division): Another division.</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: True if connected, False otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">p1</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">end_points</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">p2</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">end_points</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">end_points</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the end points of the division.</span>

<span class="sd">        Returns:</span>
<span class="sd">            list: List of end points.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">p1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">p2</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">start</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Intersection</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the start intersection of the division.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Intersection: Start intersection.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">intersections</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">end</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Intersection</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the end intersection of the division.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Intersection: End intersection.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">intersections</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span></div>



<div class="viewcode-block" id="Polyline">
<a class="viewcode-back" href="../../../simetri.lace.html#simetri.lace.lace.Polyline">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Polyline</span><span class="p">(</span><span class="n">Shape</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Connected points, similar to Shape objects.</span>
<span class="sd">    They can be closed or open.</span>
<span class="sd">    They are defined by a sequence of points.</span>
<span class="sd">    They have divisions, sections, and intersections.</span>

<span class="sd">    Args:</span>
<span class="sd">        points (list): List of points defining the polyline.</span>
<span class="sd">        closed (bool, optional): If the polyline is closed. Defaults to True.</span>
<span class="sd">        xform_matrix (array, optional): Transformation matrix. Defaults to None.</span>
<span class="sd">        **kwargs: Additional attributes for cosmetic/drawing purposes.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">points</span><span class="p">,</span> <span class="n">closed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">xform_matrix</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="s2">&quot;style&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ShapeStyle</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="s2">&quot;_style_map&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">shape_style_map</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_aliases</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">closed</span> <span class="o">=</span> <span class="n">closed</span>
        <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;subtype&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">Types</span><span class="o">.</span><span class="n">POLYLINE</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">closed</span><span class="o">=</span><span class="n">closed</span><span class="p">,</span> <span class="n">xform_matrix</span><span class="o">=</span><span class="n">xform_matrix</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_divisions</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">closed</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_intersections</span><span class="p">()</span>
        <span class="n">common_properties</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xform_matrix</span><span class="p">,</span> <span class="n">reps</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Update the transformation matrix of the polyline.</span>

<span class="sd">        Args:</span>
<span class="sd">            xform_matrix (array): Transformation matrix.</span>
<span class="sd">            reps (int, optional): Number of repetitions. Defaults to 0.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Any: Updated polyline or list of updated polylines.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">reps</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">xform_matrix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xform_matrix</span> <span class="o">@</span> <span class="n">xform_matrix</span>
            <span class="k">for</span> <span class="n">division</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">divisions</span><span class="p">:</span>
                <span class="n">division</span><span class="o">.</span><span class="n">_update</span><span class="p">(</span><span class="n">xform_matrix</span><span class="p">,</span> <span class="n">reps</span><span class="o">=</span><span class="n">reps</span><span class="p">)</span>
            <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">reps</span><span class="p">):</span>
                <span class="n">shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">shape</span><span class="o">.</span><span class="n">_update</span><span class="p">(</span><span class="n">xform_matrix</span><span class="p">)</span>
                <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">res</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;String representation of the polyline.</span>

<span class="sd">        Returns:</span>
<span class="sd">            str: String representation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;Polyline(</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">final_coords</span><span class="p">[:,</span><span class="w"> </span><span class="p">:</span><span class="mi">2</span><span class="p">]</span><span class="si">}</span><span class="s2">)&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;String representation of the polyline.</span>

<span class="sd">        Returns:</span>
<span class="sd">            str: String representation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__str__</span><span class="p">()</span>

<div class="viewcode-block" id="Polyline.iter_sections">
<a class="viewcode-back" href="../../../simetri.lace.html#simetri.lace.lace.Polyline.iter_sections">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">iter_sections</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Iterate over the sections of the polyline.</span>

<span class="sd">        Yields:</span>
<span class="sd">            Section: Section object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">division</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">divisions</span><span class="p">:</span>
            <span class="k">yield from</span> <span class="n">division</span><span class="o">.</span><span class="n">sections</span></div>


<div class="viewcode-block" id="Polyline.iter_intersections">
<a class="viewcode-back" href="../../../simetri.lace.html#simetri.lace.lace.Polyline.iter_intersections">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">iter_intersections</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Iterate over the intersections of the polyline.</span>

<span class="sd">        Yields:</span>
<span class="sd">            Intersection: Intersection object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">division</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">divisions</span><span class="p">:</span>
            <span class="k">yield from</span> <span class="n">division</span><span class="o">.</span><span class="n">intersections</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">intersections</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the intersections of the polyline.</span>

<span class="sd">        Returns:</span>
<span class="sd">            list: List of intersections.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">division</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">divisions</span><span class="p">:</span>
            <span class="n">res</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">division</span><span class="o">.</span><span class="n">intersections</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">res</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">area</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the area of the polygon.</span>

<span class="sd">        Returns:</span>
<span class="sd">            float: Area of the polygon.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">polygon_area</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vertices</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">sections</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the sections of the polyline.</span>

<span class="sd">        Returns:</span>
<span class="sd">            list: List of sections.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sections</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">division</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">divisions</span><span class="p">:</span>
            <span class="n">sections</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">division</span><span class="o">.</span><span class="n">sections</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">sections</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">divisions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the divisions of the polyline.</span>

<span class="sd">        Returns:</span>
<span class="sd">            list: List of divisions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="s2">&quot;divisions&quot;</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_set_divisions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">vertices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vertices</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">closed</span><span class="p">:</span>
            <span class="n">vertices</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">vertices</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="n">vertices</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="n">pairs</span> <span class="o">=</span> <span class="n">connected_pairs</span><span class="p">(</span><span class="n">vertices</span><span class="p">)</span>
        <span class="n">divisions</span> <span class="o">=</span> <span class="p">[</span><span class="n">Division</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">)</span> <span class="k">for</span> <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span> <span class="ow">in</span> <span class="n">pairs</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="s2">&quot;divisions&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">divisions</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_set_intersections</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Fake intersections for open lines.&quot;&quot;&quot;</span>
        <span class="n">division1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">divisions</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">division2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">divisions</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">x1</span> <span class="o">=</span> <span class="n">Intersection</span><span class="p">(</span><span class="n">division1</span><span class="o">.</span><span class="n">p1</span><span class="p">,</span> <span class="n">division1</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="n">division1</span><span class="o">.</span><span class="n">intersections</span> <span class="o">=</span> <span class="p">[</span><span class="n">x1</span><span class="p">]</span>
        <span class="n">x2</span> <span class="o">=</span> <span class="n">Intersection</span><span class="p">(</span><span class="n">division2</span><span class="o">.</span><span class="n">p2</span><span class="p">,</span> <span class="n">division2</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">division1</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">division2</span><span class="o">.</span><span class="n">id</span><span class="p">:</span>
            <span class="n">division1</span><span class="o">.</span><span class="n">intersections</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x2</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">division2</span><span class="o">.</span><span class="n">intersections</span> <span class="o">=</span> <span class="p">[</span><span class="n">x2</span><span class="p">]</span></div>



<div class="viewcode-block" id="ParallelPolyline">
<a class="viewcode-back" href="../../../simetri.lace.html#simetri.lace.lace.ParallelPolyline">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">ParallelPolyline</span><span class="p">(</span><span class="n">Batch</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A ParallelPolylines is a collection of parallel Polylines.</span>
<span class="sd">    They are defined by a main polyline and a list of offset</span>
<span class="sd">    values (that can be negative or positive).</span>

<span class="sd">    Args:</span>
<span class="sd">        polyline (Polyline): Main polyline.</span>
<span class="sd">        offset (float): Offset value.</span>
<span class="sd">        lace (Lace): Lace object.</span>
<span class="sd">        under (bool, optional): If the polyline is under. Defaults to False.</span>
<span class="sd">        closed (bool, optional): If the polyline is closed. Defaults to True.</span>
<span class="sd">        dist_tol (float, optional): Distance tolerance. Defaults to None.</span>
<span class="sd">        **kwargs: Additional attributes for cosmetic/drawing purposes.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">polyline</span><span class="p">,</span>
        <span class="n">offset</span><span class="p">,</span>
        <span class="n">lace</span><span class="p">,</span>
        <span class="n">under</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">closed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">dist_tol</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="k">if</span> <span class="n">dist_tol</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dist_tol</span> <span class="o">=</span> <span class="n">defaults</span><span class="p">[</span><span class="s2">&quot;dist_tol&quot;</span><span class="p">]</span>
        <span class="n">dist_tol2</span> <span class="o">=</span> <span class="n">dist_tol</span> <span class="o">*</span> <span class="n">dist_tol</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">polyline</span> <span class="o">=</span> <span class="n">polyline</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">offset</span> <span class="o">=</span> <span class="n">offset</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dist_tol</span> <span class="o">=</span> <span class="n">dist_tol</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dist_tol2</span> <span class="o">=</span> <span class="n">dist_tol2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">closed</span> <span class="o">=</span> <span class="n">closed</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_offset_polylines</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">polyline_list</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">polyline</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">offset_poly_list</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">polyline_list</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">subtype</span> <span class="o">=</span> <span class="n">Types</span><span class="o">.</span><span class="n">PARALLEL_POLYLINE</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">overlaps</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">under</span> <span class="o">=</span> <span class="n">under</span>
        <span class="n">common_properties</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">sections</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Section</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the sections of the parallel polyline.</span>

<span class="sd">        Returns:</span>
<span class="sd">            list: List of sections.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sects</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">polyline</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">polyline_list</span><span class="p">:</span>
            <span class="n">sects</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">polyline</span><span class="o">.</span><span class="n">sections</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">sects</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_set_offset_polylines</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">polyline</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">polyline</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">closed</span><span class="p">:</span>
            <span class="n">vertices</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">polyline</span><span class="o">.</span><span class="n">vertices</span><span class="p">)</span>
            <span class="n">vertices</span> <span class="o">=</span> <span class="n">vertices</span> <span class="o">+</span> <span class="p">[</span><span class="n">vertices</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="n">offset_polygons</span> <span class="o">=</span> <span class="n">double_offset_polygons</span><span class="p">(</span>
                <span class="n">vertices</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">offset</span><span class="p">,</span> <span class="n">dist_tol</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dist_tol</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">offset_polylines</span> <span class="o">=</span> <span class="n">double_offset_polylines</span><span class="p">(</span><span class="n">polyline</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">offset</span><span class="p">)</span>
        <span class="n">polylines</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">closed</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">polygon</span> <span class="ow">in</span> <span class="n">offset_polygons</span><span class="p">:</span>
                <span class="n">polylines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Polyline</span><span class="p">(</span><span class="n">polygon</span><span class="p">,</span> <span class="n">closed</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">closed</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">polyline</span> <span class="ow">in</span> <span class="n">offset_polylines</span><span class="p">:</span>
                <span class="n">polylines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Polyline</span><span class="p">(</span><span class="n">polyline</span><span class="p">,</span> <span class="n">closed</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">closed</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">offset_poly_list</span> <span class="o">=</span> <span class="n">polylines</span></div>



<div class="viewcode-block" id="Lace">
<a class="viewcode-back" href="../../../simetri.lace.html#simetri.lace.lace.Lace">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">Lace</span><span class="p">(</span><span class="n">Batch</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A Lace is a collection of ParallelPolylines objects.</span>
<span class="sd">    They are used to create interlace patterns.</span>

<span class="sd">    Args:</span>
<span class="sd">        polygon_shapes (Union[Batch, list[Shape]], optional): List of polygon shapes. Defaults to None.</span>
<span class="sd">        polyline_shapes (Union[Batch, list[Shape]], optional): List of polyline shapes. Defaults to None.</span>
<span class="sd">        offset (float, optional): Offset value. Defaults to 2.</span>
<span class="sd">        rtol (float, optional): Relative tolerance. Defaults to None.</span>
<span class="sd">        swatch (list, optional): Swatch list. Defaults to None.</span>
<span class="sd">        breakpoints (list, optional): Breakpoints list. Defaults to None.</span>
<span class="sd">        plait_color (colors.Color, optional): Plait color. Defaults to None.</span>
<span class="sd">        draw_fragments (bool, optional): If fragments should be drawn. Defaults to True.</span>
<span class="sd">        palette (list, optional): Palette list. Defaults to None.</span>
<span class="sd">        color_step (int, optional): Color step. Defaults to 1.</span>
<span class="sd">        with_plaits (bool, optional): If plaits should be included. Defaults to True.</span>
<span class="sd">        area_threshold (float, optional): Area threshold. Defaults to None.</span>
<span class="sd">        radius_threshold (float, optional): Radius threshold. Defaults to None.</span>
<span class="sd">        **kwargs: Additional attributes for cosmetic/drawing purposes.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># @timing</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">polygon_shapes</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Batch</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="n">Shape</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">polyline_shapes</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Batch</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="n">Shape</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">offset</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
        <span class="n">rtol</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">swatch</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">breakpoints</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">plait_color</span><span class="p">:</span> <span class="n">colors</span><span class="o">.</span><span class="n">Color</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">draw_fragments</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">palette</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">color_step</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">with_plaits</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">area_threshold</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">radius_threshold</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">validate_args</span><span class="p">(</span><span class="n">kwargs</span><span class="p">,</span> <span class="n">shape_style_map</span><span class="p">)</span>
        <span class="p">(</span>
            <span class="n">rtol</span><span class="p">,</span>
            <span class="n">swatch</span><span class="p">,</span>
            <span class="n">plait_color</span><span class="p">,</span>
            <span class="n">draw_fragments</span><span class="p">,</span>
            <span class="n">area_threshold</span><span class="p">,</span>
            <span class="n">radius_threshold</span><span class="p">,</span>
        <span class="p">)</span> <span class="o">=</span> <span class="n">get_defaults</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="s2">&quot;rtol&quot;</span><span class="p">,</span>
                <span class="s2">&quot;swatch&quot;</span><span class="p">,</span>
                <span class="s2">&quot;plait_color&quot;</span><span class="p">,</span>
                <span class="s2">&quot;draw_fragments&quot;</span><span class="p">,</span>
                <span class="s2">&quot;area_threshold&quot;</span><span class="p">,</span>
                <span class="s2">&quot;radius_threshold&quot;</span><span class="p">,</span>
            <span class="p">],</span>
            <span class="p">[</span>
                <span class="n">rtol</span><span class="p">,</span>
                <span class="n">swatch</span><span class="p">,</span>
                <span class="n">plait_color</span><span class="p">,</span>
                <span class="n">draw_fragments</span><span class="p">,</span>
                <span class="n">area_threshold</span><span class="p">,</span>
                <span class="n">radius_threshold</span><span class="p">,</span>
            <span class="p">],</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">polygon_shapes</span><span class="p">:</span>
            <span class="n">polygon_shapes</span> <span class="o">=</span> <span class="n">polygon_shapes</span><span class="o">.</span><span class="n">merge_shapes</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">polygon_shapes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_polygons</span><span class="p">(</span><span class="n">polygon_shapes</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">polygon_shapes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">polyline_shapes</span><span class="p">:</span>
            <span class="n">polyline_shapes</span> <span class="o">=</span> <span class="n">polyline_shapes</span><span class="o">.</span><span class="n">merge_shapes</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">polyline_shapes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_polylines</span><span class="p">(</span><span class="n">polyline_shapes</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">polyline_shapes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">polygon_shapes</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">polyline_shapes</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Lace.__init__ : No polygons or polylines found.&quot;</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">polyline_shapes</span> <span class="o">=</span> <span class="n">polyline_shapes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">offset</span> <span class="o">=</span> <span class="n">offset</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">main_intersections</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">offset_intersections</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xform_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rtol</span> <span class="o">=</span> <span class="n">rtol</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">swatch</span> <span class="o">=</span> <span class="n">swatch</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">breakpoints</span> <span class="o">=</span> <span class="n">breakpoints</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">plait_color</span> <span class="o">=</span> <span class="n">plait_color</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">draw_fragments</span> <span class="o">=</span> <span class="n">draw_fragments</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">palette</span> <span class="o">=</span> <span class="n">palette</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">color_step</span> <span class="o">=</span> <span class="n">color_step</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">with_plaits</span> <span class="o">=</span> <span class="n">with_plaits</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">d_intersections</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># key, value:intersection.id, intersection</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">d_connections</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">plaits</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">overlaps</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_groups</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">area_threshold</span> <span class="o">=</span> <span class="n">area_threshold</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">radius_threshold</span> <span class="o">=</span> <span class="n">radius_threshold</span>
        <span class="k">if</span> <span class="n">kwargs</span> <span class="ow">and</span> <span class="s2">&quot;_copy&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="c1"># pass the pre-computed values</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="s2">&quot;_copy&quot;</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_polyline_list</span><span class="p">()</span>  <span class="c1"># main divisions are set here along with polylines</span>
            <span class="c1"># polyline.divisions is the list of Division objects</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_parallel_poly_list</span><span class="p">()</span>
            <span class="c1"># start_time2 = time.perf_counter()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_intersections</span><span class="p">()</span>
            <span class="c1"># end_time2 = time.perf_counter()</span>
            <span class="c1"># print(</span>
            <span class="c1">#     f&quot;Lace.__init__ intersections computed in {end_time2 - start_time2:0.4f} seconds&quot;</span>
            <span class="c1"># )</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_set_overlaps</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_twin_sections</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_fragments</span><span class="p">()</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">polyline_shapes</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_set_outline</span><span class="p">()</span>
            <span class="c1"># self._set_partitions()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_over_under</span><span class="p">()</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">with_plaits</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_plaits</span><span class="p">()</span>
            <span class="c1"># self._set_convex_hull()</span>
            <span class="c1"># self._set_concave_hull()</span>
            <span class="c1"># self._set_fragment_groups()</span>
            <span class="c1"># self._set_partition_groups()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_b_box</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">elements</span> <span class="o">=</span> <span class="p">[</span><span class="n">polyline</span> <span class="k">for</span> <span class="n">polyline</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parallel_poly_list</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">fragments</span>

        <span class="k">if</span> <span class="s2">&quot;debug&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;debug&quot;</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">elements</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">kwargs</span> <span class="ow">and</span> <span class="s2">&quot;_copy&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">shape_style_map</span><span class="p">:</span>
                    <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>  <span class="c1"># todo: we should check for valid values here</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">. Invalid attribute!&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">subtype</span> <span class="o">=</span> <span class="n">Types</span><span class="o">.</span><span class="n">LACE</span>
        <span class="n">common_properties</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">center</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the center of the lace.</span>

<span class="sd">        Returns:</span>
<span class="sd">            list: Center coordinates.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">outline</span><span class="o">.</span><span class="n">CG</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">fragment_groups</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the fragment groups of the lace.</span>

<span class="sd">        Returns:</span>
<span class="sd">            dict: Dictionary of fragment groups.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">center</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">center</span>
        <span class="n">radius_frag</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">fragment</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fragments</span><span class="p">:</span>
            <span class="n">radius</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">distance</span><span class="p">(</span><span class="n">center</span><span class="p">,</span> <span class="n">fragment</span><span class="o">.</span><span class="n">CG</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">rad</span><span class="p">,</span> <span class="n">frag</span> <span class="ow">in</span> <span class="n">radius_frag</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">radius</span> <span class="o">-</span> <span class="n">rad</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">radius</span> <span class="o">=</span> <span class="n">rad</span>
                    <span class="k">break</span>
            <span class="n">radius_frag</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">radius</span><span class="p">,</span> <span class="n">fragment</span><span class="p">))</span>

        <span class="n">radius_frag</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="n">d_groups</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">radius</span><span class="p">,</span> <span class="n">fragment</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">radius_frag</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">d_groups</span><span class="p">[</span><span class="n">radius</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">fragment</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">radius</span> <span class="ow">in</span> <span class="n">d_groups</span><span class="p">:</span>
                    <span class="n">d_groups</span><span class="p">[</span><span class="n">radius</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fragment</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">d_groups</span><span class="p">[</span><span class="n">radius</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">fragment</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">d_groups</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_check_polygons</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">polygon_shapes</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">polygon_shapes</span><span class="p">,</span> <span class="n">Batch</span><span class="p">):</span>
            <span class="n">polygon_shapes</span> <span class="o">=</span> <span class="n">polygon_shapes</span><span class="o">.</span><span class="n">all_shapes</span>
        <span class="k">for</span> <span class="n">polygon</span> <span class="ow">in</span> <span class="n">polygon_shapes</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">polygon</span><span class="o">.</span><span class="n">primary_points</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Lace.__init__ found polygon with less than 3 points.&quot;</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">polygon</span><span class="o">.</span><span class="n">closed</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Lace.__init__ : Invalid polygons&quot;</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">polygon</span><span class="o">.</span><span class="n">primary_points</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">polygon</span><span class="o">.</span><span class="n">primary_points</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">polygon</span><span class="o">.</span><span class="n">primary_points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">polygon</span><span class="o">.</span><span class="n">primary_points</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="c1"># check if the polygons are clockwise</span>
        <span class="k">for</span> <span class="n">polygon</span> <span class="ow">in</span> <span class="n">polygon_shapes</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">right_handed</span><span class="p">(</span><span class="n">polygon</span><span class="o">.</span><span class="n">vertices</span><span class="p">):</span>
                <span class="n">polygon</span><span class="o">.</span><span class="n">primary_points</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">polygon_shapes</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_check_polylines</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">polyline_shapes</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">polyline_shapes</span><span class="p">,</span> <span class="n">Batch</span><span class="p">):</span>
            <span class="n">polyline_shapes</span> <span class="o">=</span> <span class="n">polyline_shapes</span><span class="o">.</span><span class="n">all_shapes</span>
        <span class="k">for</span> <span class="n">polyline</span> <span class="ow">in</span> <span class="n">polyline_shapes</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">polyline</span><span class="o">.</span><span class="n">primary_points</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Lace.__init__ found polyline with less than 2 points.&quot;</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">polyline_shapes</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xform_matrix</span><span class="p">,</span> <span class="n">reps</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Update the transformation matrix of the lace.</span>

<span class="sd">        Args:</span>
<span class="sd">            xform_matrix (array): Transformation matrix.</span>
<span class="sd">            reps (int, optional): Number of repetitions. Defaults to 0.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Any: Updated lace or list of updated laces.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">reps</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">xform_matrix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xform_matrix</span> <span class="o">@</span> <span class="n">xform_matrix</span>
            <span class="k">for</span> <span class="n">polygon</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">polygon_shapes</span><span class="p">:</span>
                <span class="n">polygon</span><span class="o">.</span><span class="n">_update</span><span class="p">(</span><span class="n">xform_matrix</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">polyline_shapes</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">polyline</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">polyline_shapes</span><span class="p">:</span>
                    <span class="n">polyline</span><span class="o">.</span><span class="n">_update</span><span class="p">(</span><span class="n">xform_matrix</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">polyline</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parallel_poly_list</span><span class="p">:</span>
                <span class="n">polyline</span><span class="o">.</span><span class="n">_update</span><span class="p">(</span><span class="n">xform_matrix</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">fragment</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fragments</span><span class="p">:</span>
                <span class="n">fragment</span><span class="o">.</span><span class="n">_update</span><span class="p">(</span><span class="n">xform_matrix</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">intersection</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">main_intersections</span><span class="p">:</span>
                <span class="n">intersection</span><span class="o">.</span><span class="n">_update</span><span class="p">(</span><span class="n">xform_matrix</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">intersection</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">offset_intersections</span><span class="p">:</span>
                <span class="n">intersection</span><span class="o">.</span><span class="n">_update</span><span class="p">(</span><span class="n">xform_matrix</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">overlap</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">overlaps</span><span class="p">:</span>
                <span class="n">overlap</span><span class="o">.</span><span class="n">_update</span><span class="p">(</span><span class="n">xform_matrix</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">plait</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">plaits</span><span class="p">:</span>
                <span class="n">plait</span><span class="o">.</span><span class="n">_update</span><span class="p">(</span><span class="n">xform_matrix</span><span class="p">)</span>

            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">reps</span><span class="p">):</span>
                <span class="n">shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">shape</span><span class="o">.</span><span class="n">_update</span><span class="p">(</span><span class="n">xform_matrix</span><span class="p">)</span>
                <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">res</span>

    <span class="c1"># @timing</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_set_twin_sections</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">par_poly</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parallel_poly_list</span><span class="p">:</span>
            <span class="n">poly1</span><span class="p">,</span> <span class="n">poly2</span> <span class="o">=</span> <span class="n">par_poly</span><span class="o">.</span><span class="n">offset_poly_list</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">sec</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">poly1</span><span class="o">.</span><span class="n">iter_sections</span><span class="p">()):</span>
                <span class="n">sec1</span> <span class="o">=</span> <span class="n">sec</span>
                <span class="n">sec2</span> <span class="o">=</span> <span class="n">poly2</span><span class="o">.</span><span class="n">sections</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">sec1</span><span class="o">.</span><span class="n">twin</span> <span class="o">=</span> <span class="n">sec2</span>
                <span class="n">sec2</span><span class="o">.</span><span class="n">twin</span> <span class="o">=</span> <span class="n">sec1</span>

    <span class="c1"># @timing</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_set_partitions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">fragment</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fragments</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">partitions</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">fragment</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fragments</span><span class="p">:</span>
                <span class="n">partition</span> <span class="o">=</span> <span class="n">Shape</span><span class="p">(</span><span class="n">offset_polygon</span><span class="p">(</span><span class="n">fragment</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">offset</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">partitions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">partition</span><span class="p">)</span>

    <span class="c1"># To do: This doesn&#39;t work if we have polyline shapes!</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_set_outline</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># outline is a special fragment that covers the whole lace</span>
        <span class="n">areas</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">fragment</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fragments</span><span class="p">:</span>
            <span class="n">areas</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">fragment</span><span class="o">.</span><span class="n">area</span><span class="p">,</span> <span class="n">fragment</span><span class="p">))</span>
        <span class="n">areas</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">outline</span> <span class="o">=</span> <span class="n">areas</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fragments</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outline</span><span class="p">)</span>
        <span class="c1"># perimenter is the outline of the partitions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">perimeter</span> <span class="o">=</span> <span class="n">Shape</span><span class="p">(</span><span class="n">offset_polygon</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outline</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">offset</span><span class="p">))</span>
        <span class="c1"># skeleton is the input polylines that the lace is based on</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">skeleton</span> <span class="o">=</span> <span class="n">Batch</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">polyline_list</span><span class="p">)</span>

<div class="viewcode-block" id="Lace.set_fragment_groups">
<a class="viewcode-back" href="../../../simetri.lace.html#simetri.lace.lace.Lace.set_fragment_groups">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">set_fragment_groups</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># to do : handle repeated code. same in _set_partition_groups</span>
        <span class="n">areas</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">fragment</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fragments</span><span class="p">):</span>
            <span class="n">areas</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">fragment</span><span class="o">.</span><span class="n">area</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span>
        <span class="n">areas</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
        <span class="n">bins</span> <span class="o">=</span> <span class="n">group_into_bins</span><span class="p">(</span><span class="n">areas</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">area_threshold</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fragments_by_area</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="nb">bin</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">bins</span><span class="p">):</span>
            <span class="n">area_values</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">bin</span><span class="p">]</span>
            <span class="n">key</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">bin</span><span class="p">])</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="nb">bin</span><span class="p">)</span>
            <span class="n">fragments</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">area</span><span class="p">,</span> <span class="n">ind</span> <span class="ow">in</span> <span class="n">areas</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">area</span> <span class="ow">in</span> <span class="n">area_values</span><span class="p">:</span>
                    <span class="n">fragments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fragments</span><span class="p">[</span><span class="n">ind</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fragments_by_area</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">fragments</span>

        <span class="n">radii</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">fragment</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fragments</span><span class="p">):</span>
            <span class="n">radii</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">distance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">center</span><span class="p">,</span> <span class="n">fragment</span><span class="o">.</span><span class="n">CG</span><span class="p">),</span> <span class="n">i</span><span class="p">))</span>
        <span class="n">radii</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
        <span class="n">bins</span> <span class="o">=</span> <span class="n">group_into_bins</span><span class="p">(</span><span class="n">radii</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">radius_threshold</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fragments_by_radius</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="nb">bin</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">bins</span><span class="p">):</span>
            <span class="n">radius_values</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">bin</span><span class="p">]</span>
            <span class="n">key</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">bin</span><span class="p">])</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="nb">bin</span><span class="p">)</span>
            <span class="n">fragments</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">radius</span><span class="p">,</span> <span class="n">ind</span> <span class="ow">in</span> <span class="n">radii</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">radius</span> <span class="ow">in</span> <span class="n">radius_values</span><span class="p">:</span>
                    <span class="n">fragments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fragments</span><span class="p">[</span><span class="n">ind</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fragments_by_radius</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">fragments</span></div>


    <span class="c1"># @timing</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_set_partition_groups</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># to do : handle repeated code. same in set_fragment_groups</span>
        <span class="n">areas</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">partition</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">partitions</span><span class="p">):</span>
            <span class="n">areas</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">partition</span><span class="o">.</span><span class="n">area</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span>
        <span class="n">areas</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
        <span class="n">bins</span> <span class="o">=</span> <span class="n">group_into_bins</span><span class="p">(</span><span class="n">areas</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">area_threshold</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">partitions_by_area</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">bin_</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">bins</span><span class="p">):</span>
            <span class="n">area_values</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">bin_</span><span class="p">]</span>
            <span class="n">key</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">bin_</span><span class="p">])</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">bin_</span><span class="p">)</span>
            <span class="n">partitions</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">area</span><span class="p">,</span> <span class="n">ind</span> <span class="ow">in</span> <span class="n">areas</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">area</span> <span class="ow">in</span> <span class="n">area_values</span><span class="p">:</span>
                    <span class="n">partitions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">partitions</span><span class="p">[</span><span class="n">ind</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">partitions_by_area</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">partitions</span>

        <span class="n">radii</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">partition</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">partitions</span><span class="p">):</span>
            <span class="n">CG</span> <span class="o">=</span> <span class="n">polygon_center</span><span class="p">(</span><span class="n">partition</span><span class="o">.</span><span class="n">vertices</span><span class="p">)</span>
            <span class="n">radii</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">distance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">center</span><span class="p">,</span> <span class="n">CG</span><span class="p">),</span> <span class="n">i</span><span class="p">))</span>
        <span class="n">radii</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
        <span class="n">bins</span> <span class="o">=</span> <span class="n">group_into_bins</span><span class="p">(</span><span class="n">radii</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">radius_threshold</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">partitions_by_radius</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">bin_</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">bins</span><span class="p">):</span>
            <span class="n">radius_values</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">bin_</span><span class="p">]</span>
            <span class="n">key</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">bin_</span><span class="p">])</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">bin_</span><span class="p">)</span>
            <span class="n">partitions</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">radius</span><span class="p">,</span> <span class="n">ind</span> <span class="ow">in</span> <span class="n">radii</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">radius</span> <span class="ow">in</span> <span class="n">radius_values</span><span class="p">:</span>
                    <span class="n">partitions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">partitions</span><span class="p">[</span><span class="n">ind</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">partitions_by_radius</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">partitions</span>

    <span class="c1"># @timing</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_set_fragments</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">section</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_offset_sections</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">section</span><span class="o">.</span><span class="n">is_overlap</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">section</span><span class="o">.</span><span class="n">start</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">section</span><span class="o">.</span><span class="n">end</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">section</span><span class="o">=</span><span class="n">section</span><span class="p">)</span>

        <span class="n">cycles</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">cycle_basis</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
        <span class="n">fragments</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">d_x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">d_intersections</span>
        <span class="k">for</span> <span class="n">cycle</span> <span class="ow">in</span> <span class="n">cycles</span><span class="p">:</span>
            <span class="n">cycle</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cycle</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">nodes</span> <span class="o">=</span> <span class="n">cycle</span>
            <span class="n">edges</span> <span class="o">=</span> <span class="n">connected_pairs</span><span class="p">(</span><span class="n">cycle</span><span class="p">)</span>
            <span class="n">sections</span> <span class="o">=</span> <span class="p">[</span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">edge</span><span class="p">][</span><span class="s2">&quot;section&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">]</span>
            <span class="n">s_intersections</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">section</span> <span class="ow">in</span> <span class="n">sections</span><span class="p">:</span>
                <span class="n">s_intersections</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">section</span><span class="o">.</span><span class="n">start</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
                <span class="n">s_intersections</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">section</span><span class="o">.</span><span class="n">end</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
            <span class="n">intersections</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">d_intersections</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">s_intersections</span><span class="p">]</span>
            <span class="n">points</span> <span class="o">=</span> <span class="p">[</span><span class="n">d_x</span><span class="p">[</span><span class="n">x_id</span><span class="p">]</span><span class="o">.</span><span class="n">point</span> <span class="k">for</span> <span class="n">x_id</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">right_handed</span><span class="p">(</span><span class="n">points</span><span class="p">):</span>
                <span class="n">points</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
            <span class="n">fragment</span> <span class="o">=</span> <span class="n">Fragment</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
            <span class="n">fragment</span><span class="o">.</span><span class="n">sections</span> <span class="o">=</span> <span class="n">sections</span>
            <span class="n">fragment</span><span class="o">.</span><span class="n">intersections</span> <span class="o">=</span> <span class="n">intersections</span>
            <span class="n">fragments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fragment</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">fragment</span> <span class="ow">in</span> <span class="n">fragments</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">section</span> <span class="ow">in</span> <span class="n">fragment</span><span class="o">.</span><span class="n">sections</span><span class="p">:</span>
                <span class="n">section</span><span class="o">.</span><span class="n">fragment</span> <span class="o">=</span> <span class="n">fragment</span>

        <span class="k">for</span> <span class="n">fragment</span> <span class="ow">in</span> <span class="n">fragments</span><span class="p">:</span>
            <span class="n">fragment</span><span class="o">.</span><span class="n">_set_divisions</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">fragment</span> <span class="ow">in</span> <span class="n">fragments</span><span class="p">:</span>
            <span class="n">fragment</span><span class="o">.</span><span class="n">_set_twin_divisions</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">fragments</span> <span class="o">=</span> <span class="n">fragments</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_set_concave_hull</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">concave_hull</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">outline</span><span class="o">.</span><span class="n">vertices</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_set_convex_hull</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">convex_hull</span> <span class="o">=</span> <span class="n">convex_hull</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outline</span><span class="o">.</span><span class="n">vertices</span><span class="p">)</span>

<div class="viewcode-block" id="Lace.copy">
<a class="viewcode-back" href="../../../simetri.lace.html#simetri.lace.lace.Lace.copy">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">class</span><span class="w"> </span><span class="nc">Dummy</span><span class="p">(</span><span class="n">Lace</span><span class="p">):</span>
            <span class="k">pass</span>

        <span class="c1"># we need to copy the polyline_list and parallel_poly_list</span>
        <span class="k">for</span> <span class="n">polyline</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">polyline_list</span><span class="p">:</span>
            <span class="n">polyline</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span></div>


<div class="viewcode-block" id="Lace.get_sketch">
<a class="viewcode-back" href="../../../simetri.lace.html#simetri.lace.lace.Lace.get_sketch">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_sketch</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create and return a Sketch object. Sketch is a Batch object</span>
<span class="sd">        with Shape elements corresponding to the vertices of the plaits</span>
<span class="sd">        and fragments of the Lace instance. They have &#39;plaits&#39; and</span>
<span class="sd">        &#39;fragments&#39; attributes to hold lists of Shape objects populated</span>
<span class="sd">        with plait and fragment vertices of the Lace instance</span>
<span class="sd">        respectively. They are used for drawing multiple copies of the</span>
<span class="sd">        original lace pattern. They are light-weight compared to the</span>
<span class="sd">        Lace objects since they only contain sufficient data to draw the</span>
<span class="sd">        lace objects. Hundreds of these objects can be used to create</span>
<span class="sd">        wallpaper patterns or other patterns without having to contain</span>
<span class="sd">        unnecessary data. They do not share points with the original</span>
<span class="sd">        Lace object.</span>

<span class="sd">        Arguments:</span>
<span class="sd">        ----------</span>
<span class="sd">            None</span>

<span class="sd">        Prerequisites:</span>
<span class="sd">        --------------</span>
<span class="sd">            * A lace object to be copied.</span>

<span class="sd">        Side effects:</span>
<span class="sd">        -------------</span>
<span class="sd">            None</span>

<span class="sd">        Return:</span>
<span class="sd">        --------</span>
<span class="sd">            A Sketch object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">fragments</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">fragment</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fragments</span><span class="p">:</span>
            <span class="n">polygon</span> <span class="o">=</span> <span class="n">Shape</span><span class="p">(</span><span class="n">fragment</span><span class="o">.</span><span class="n">vertices</span><span class="p">)</span>
            <span class="n">polygon</span><span class="o">.</span><span class="n">fill</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">polygon</span><span class="o">.</span><span class="n">subtype</span> <span class="o">=</span> <span class="n">Types</span><span class="o">.</span><span class="n">FRAGMENT</span>
            <span class="n">fragments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">polygon</span><span class="p">)</span>

        <span class="n">plaits</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">plait</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">plaits</span><span class="p">:</span>
            <span class="n">polygon</span> <span class="o">=</span> <span class="n">Shape</span><span class="p">(</span><span class="n">plait</span><span class="o">.</span><span class="n">vertices</span><span class="p">)</span>
            <span class="n">polygon</span><span class="o">.</span><span class="n">fill</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">polygon</span><span class="o">.</span><span class="n">subtype</span> <span class="o">=</span> <span class="n">Types</span><span class="o">.</span><span class="n">PLAIT</span>
            <span class="n">plaits</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">polygon</span><span class="p">)</span>

        <span class="n">sketch</span> <span class="o">=</span> <span class="n">Batch</span><span class="p">((</span><span class="n">fragments</span> <span class="o">+</span> <span class="n">plaits</span><span class="p">))</span>
        <span class="n">sketch</span><span class="o">.</span><span class="n">fragments</span> <span class="o">=</span> <span class="n">fragments</span>
        <span class="n">sketch</span><span class="o">.</span><span class="n">plaits</span> <span class="o">=</span> <span class="n">plaits</span>
        <span class="n">sketch</span><span class="o">.</span><span class="n">outline</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">outline</span>
        <span class="n">sketch</span><span class="o">.</span><span class="n">subtype</span> <span class="o">=</span> <span class="n">Types</span><span class="o">.</span><span class="n">SKETCH</span>

        <span class="n">sketch</span><span class="o">.</span><span class="n">draw_plaits</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">sketch</span><span class="o">.</span><span class="n">draw_fragments</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="n">sketch</span></div>


<div class="viewcode-block" id="Lace.group_fragments">
<a class="viewcode-back" href="../../../simetri.lace.html#simetri.lace.lace.Lace.group_fragments">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">group_fragments</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Group the fragments by the number of vertices and the area.</span>

<span class="sd">        Args:</span>
<span class="sd">            tol (float, optional): Tolerance value. Defaults to None.</span>

<span class="sd">        Returns:</span>
<span class="sd">            list: List of grouped fragments.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">tol</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tol</span> <span class="o">=</span> <span class="n">defaults</span><span class="p">[</span><span class="s2">&quot;tol&quot;</span><span class="p">]</span>
        <span class="n">frags</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fragments</span>
        <span class="n">vert_groups</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">[</span><span class="n">frag</span> <span class="k">for</span> <span class="n">frag</span> <span class="ow">in</span> <span class="n">frags</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">frag</span><span class="o">.</span><span class="n">vertices</span><span class="p">)</span> <span class="o">==</span> <span class="n">n</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">vertices</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">frags</span><span class="p">])</span>
        <span class="p">]</span>
        <span class="n">groups</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">vert_groups</span><span class="p">:</span>
            <span class="n">areas</span> <span class="o">=</span> <span class="p">[</span>
                <span class="p">[</span><span class="n">f</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">group</span> <span class="k">if</span> <span class="n">isclose</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">area</span><span class="p">,</span> <span class="n">area</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="n">tol</span><span class="p">)]</span>
                <span class="k">for</span> <span class="n">area</span> <span class="ow">in</span> <span class="nb">set</span><span class="p">([</span><span class="n">frag</span><span class="o">.</span><span class="n">area</span> <span class="k">for</span> <span class="n">frag</span> <span class="ow">in</span> <span class="n">group</span><span class="p">])</span>
            <span class="p">]</span>
            <span class="n">areas</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">area</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">groups</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">areas</span><span class="p">)</span>
        <span class="n">groups</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">area</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">groups</span></div>


<div class="viewcode-block" id="Lace.get_fragment_cycles">
<a class="viewcode-back" href="../../../simetri.lace.html#simetri.lace.lace.Lace.get_fragment_cycles">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">get_fragment_cycles</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterate over the offset sections and create a graph of the</span>
<span class="sd">        intersections (start and end of the sections). Then find the</span>
<span class="sd">        cycles in the graph. self.d_intersections is used to map</span>
<span class="sd">        the graph nodes to the actual intersection points.</span>

<span class="sd">        Returns:</span>
<span class="sd">            list: List of fragment cycles.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">graph_edges</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">section</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_offset_sections</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">section</span><span class="o">.</span><span class="n">is_overlap</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">graph_edges</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">section</span><span class="o">.</span><span class="n">start</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">section</span><span class="o">.</span><span class="n">end</span><span class="o">.</span><span class="n">id</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">get_cycles</span><span class="p">(</span><span class="n">graph_edges</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_set_inner_lines</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">line_color</span><span class="o">=</span><span class="n">colors</span><span class="o">.</span><span class="n">blue</span><span class="p">,</span> <span class="n">line_width</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="n">vertices</span> <span class="o">=</span> <span class="n">item</span><span class="o">.</span><span class="n">vertices</span>
            <span class="n">dist_tol</span> <span class="o">=</span> <span class="n">defaults</span><span class="p">[</span><span class="s2">&quot;dist_tol&quot;</span><span class="p">]</span>
            <span class="n">offset_poly</span> <span class="o">=</span> <span class="n">offset_polygon_points</span><span class="p">(</span>
                <span class="n">vertices</span><span class="p">,</span> <span class="n">offset</span> <span class="o">*</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">dist_tol</span><span class="o">=</span><span class="n">dist_tol</span>
            <span class="p">)</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="n">Shape</span><span class="p">(</span><span class="n">offset_poly</span><span class="p">)</span>
            <span class="n">shape</span><span class="o">.</span><span class="n">fill</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">shape</span><span class="o">.</span><span class="n">line_width</span> <span class="o">=</span> <span class="n">line_width</span>
            <span class="n">shape</span><span class="o">.</span><span class="n">line_color</span> <span class="o">=</span> <span class="n">line_color</span>
            <span class="n">item</span><span class="o">.</span><span class="n">inner_lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>

<div class="viewcode-block" id="Lace.set_plait_lines">
<a class="viewcode-back" href="../../../simetri.lace.html#simetri.lace.lace.Lace.set_plait_lines">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">set_plait_lines</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">line_color</span><span class="o">=</span><span class="n">colors</span><span class="o">.</span><span class="n">blue</span><span class="p">,</span> <span class="n">line_width</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create offset lines inside the plaits of the lace.</span>

<span class="sd">        Args:</span>
<span class="sd">            n (int): Number of lines.</span>
<span class="sd">            offset (float): Offset value.</span>
<span class="sd">            line_color (colors.Color, optional): Line color. Defaults to colors.blue.</span>
<span class="sd">            line_width (int, optional): Line width. Defaults to 1.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">plait</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">plaits</span><span class="p">:</span>
            <span class="n">plait</span><span class="o">.</span><span class="n">inner_lines</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_inner_lines</span><span class="p">(</span><span class="n">plait</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">line_color</span><span class="p">,</span> <span class="n">line_width</span><span class="p">)</span></div>


<div class="viewcode-block" id="Lace.set_fragment_lines">
<a class="viewcode-back" href="../../../simetri.lace.html#simetri.lace.lace.Lace.set_fragment_lines">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">set_fragment_lines</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">offset</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">line_color</span><span class="p">:</span> <span class="n">colors</span><span class="o">.</span><span class="n">Color</span> <span class="o">=</span> <span class="n">colors</span><span class="o">.</span><span class="n">blue</span><span class="p">,</span>
        <span class="n">line_width</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create offset lines inside the fragments of the lace.</span>

<span class="sd">        Args:</span>
<span class="sd">            n (int): Number of lines.</span>
<span class="sd">            offset (float): Offset value.</span>
<span class="sd">            line_color (colors.Color, optional): Line color. Defaults to colors.blue.</span>
<span class="sd">            line_width (int, optional): Line width. Defaults to 1.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">fragment</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fragments</span><span class="p">:</span>
            <span class="n">fragment</span><span class="o">.</span><span class="n">inner_lines</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_inner_lines</span><span class="p">(</span><span class="n">fragment</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">line_color</span><span class="p">,</span> <span class="n">line_width</span><span class="p">)</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">all_divisions</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a list of all the divisions (both main and offset) in the lace.</span>

<span class="sd">        Returns:</span>
<span class="sd">            list: List of all divisions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">parallel_polyline</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parallel_poly_list</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">polyline</span> <span class="ow">in</span> <span class="n">parallel_polyline</span><span class="o">.</span><span class="n">polyline_list</span><span class="p">:</span>
                <span class="n">res</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">polyline</span><span class="o">.</span><span class="n">divisions</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">res</span>

<div class="viewcode-block" id="Lace.iter_main_intersections">
<a class="viewcode-back" href="../../../simetri.lace.html#simetri.lace.lace.Lace.iter_main_intersections">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">iter_main_intersections</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Iterate over the main intersections.</span>

<span class="sd">        Yields:</span>
<span class="sd">            Intersection: Intersection object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">ppoly</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parallel_poly_list</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">division</span> <span class="ow">in</span> <span class="n">ppoly</span><span class="o">.</span><span class="n">polyline</span><span class="o">.</span><span class="n">divisions</span><span class="p">:</span>
                <span class="k">yield from</span> <span class="n">division</span><span class="o">.</span><span class="n">intersections</span></div>


<div class="viewcode-block" id="Lace.iter_offset_intersections">
<a class="viewcode-back" href="../../../simetri.lace.html#simetri.lace.lace.Lace.iter_offset_intersections">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">iter_offset_intersections</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterate over the offset intersections.</span>

<span class="sd">        Yields:</span>
<span class="sd">            Intersection: Intersection object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">ppoly</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parallel_poly_list</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">poly</span> <span class="ow">in</span> <span class="n">ppoly</span><span class="o">.</span><span class="n">offset_poly_list</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">division</span> <span class="ow">in</span> <span class="n">poly</span><span class="o">.</span><span class="n">divisions</span><span class="p">:</span>
                    <span class="k">yield from</span> <span class="n">division</span><span class="o">.</span><span class="n">intersections</span></div>


<div class="viewcode-block" id="Lace.iter_offset_sections">
<a class="viewcode-back" href="../../../simetri.lace.html#simetri.lace.lace.Lace.iter_offset_sections">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">iter_offset_sections</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterate over the offset sections.</span>

<span class="sd">        Yields:</span>
<span class="sd">            Section: Section object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">ppoly</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parallel_poly_list</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">poly</span> <span class="ow">in</span> <span class="n">ppoly</span><span class="o">.</span><span class="n">offset_poly_list</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">division</span> <span class="ow">in</span> <span class="n">poly</span><span class="o">.</span><span class="n">divisions</span><span class="p">:</span>
                    <span class="k">yield from</span> <span class="n">division</span><span class="o">.</span><span class="n">sections</span></div>


<div class="viewcode-block" id="Lace.iter_main_sections">
<a class="viewcode-back" href="../../../simetri.lace.html#simetri.lace.lace.Lace.iter_main_sections">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">iter_main_sections</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Iterate over the main sections.</span>

<span class="sd">        Yields:</span>
<span class="sd">            Section: Section object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">ppoly</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parallel_poly_list</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">division</span> <span class="ow">in</span> <span class="n">ppoly</span><span class="o">.</span><span class="n">polyline</span><span class="o">.</span><span class="n">divisions</span><span class="p">:</span>
                <span class="k">yield from</span> <span class="n">division</span><span class="o">.</span><span class="n">sections</span></div>


<div class="viewcode-block" id="Lace.iter_offset_divisions">
<a class="viewcode-back" href="../../../simetri.lace.html#simetri.lace.lace.Lace.iter_offset_divisions">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">iter_offset_divisions</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterate over the offset divisions.</span>

<span class="sd">        Yields:</span>
<span class="sd">            Division: Division object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">ppoly</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parallel_poly_list</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">poly</span> <span class="ow">in</span> <span class="n">ppoly</span><span class="o">.</span><span class="n">offset_poly_list</span><span class="p">:</span>
                <span class="k">yield from</span> <span class="n">poly</span><span class="o">.</span><span class="n">divisions</span></div>


<div class="viewcode-block" id="Lace.iter_main_divisions">
<a class="viewcode-back" href="../../../simetri.lace.html#simetri.lace.lace.Lace.iter_main_divisions">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">iter_main_divisions</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterate over the main divisions.</span>

<span class="sd">        Yields:</span>
<span class="sd">            Division: Division object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">ppoly</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parallel_poly_list</span><span class="p">:</span>
            <span class="k">yield from</span> <span class="n">ppoly</span><span class="o">.</span><span class="n">polyline</span><span class="o">.</span><span class="n">divisions</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">main_divisions</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Division</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Main divisions are the divisions of the main polyline.</span>

<span class="sd">        Returns:</span>
<span class="sd">            list: List of main divisions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">parallel_polyline</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parallel_poly_list</span><span class="p">:</span>
            <span class="n">res</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">parallel_polyline</span><span class="o">.</span><span class="n">polyline</span><span class="o">.</span><span class="n">divisions</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">res</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">offset_divisions</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Division</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Offset divisions are the divisions of the offset polylines.</span>

<span class="sd">        Returns:</span>
<span class="sd">            list: List of offset divisions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">parallel_polyline</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parallel_poly_list</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">polyline</span> <span class="ow">in</span> <span class="n">parallel_polyline</span><span class="o">.</span><span class="n">offset_poly_list</span><span class="p">:</span>
                <span class="n">res</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">polyline</span><span class="o">.</span><span class="n">divisions</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">res</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">intersections</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Intersection</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return all the intersections in the parallel_poly_list.</span>

<span class="sd">        Returns:</span>
<span class="sd">            list: List of intersections.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">parallel_polyline</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parallel_poly_list</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">polyline</span> <span class="ow">in</span> <span class="n">parallel_polyline</span><span class="o">.</span><span class="n">polyline_list</span><span class="p">:</span>
                <span class="n">res</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">polyline</span><span class="o">.</span><span class="n">intersections</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">res</span>

    <span class="c1"># @timing</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_set_polyline_list</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Populate the self.polyline_list list with Polyline objects.</span>

<span class="sd">        * Internal use only.</span>

<span class="sd">        Arguments:</span>
<span class="sd">        ----------</span>
<span class="sd">            None</span>

<span class="sd">        Return:</span>
<span class="sd">        --------</span>
<span class="sd">            None</span>

<span class="sd">        Prerequisites:</span>
<span class="sd">        --------------</span>

<span class="sd">            * self.polygon_shapes and/or self.polyline_shapes must be</span>
<span class="sd">              established.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">polyline_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">polygon_shapes</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">polygon</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">polygon_shapes</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">polyline_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Polyline</span><span class="p">(</span><span class="n">polygon</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span> <span class="n">closed</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">polyline_shapes</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">polyline</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">polyline_shapes</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">polyline_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Polyline</span><span class="p">(</span><span class="n">polyline</span><span class="o">.</span><span class="n">vertices</span><span class="p">,</span> <span class="n">closed</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>

    <span class="c1"># @timing</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_set_parallel_poly_list</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Populate the self.parallel_poly_list list with ParallelPolyline</span>
<span class="sd">        objects.</span>

<span class="sd">        Arguments:</span>
<span class="sd">        ----------</span>
<span class="sd">            None</span>

<span class="sd">        Return:</span>
<span class="sd">        --------</span>
<span class="sd">            None</span>

<span class="sd">        Prerequisites:</span>
<span class="sd">        --------------</span>
<span class="sd">            * self.polygon_shapes and/or self.polyline_shapes must be</span>
<span class="sd">              established prior to this.</span>
<span class="sd">            * Parallel polylines are created by offsetting the original</span>
<span class="sd">              polygon and polyline shapes in two directions using the</span>
<span class="sd">              self.offset value.</span>

<span class="sd">        Notes:</span>
<span class="sd">        ------</span>
<span class="sd">            This method is called by the Lace constructor.  It is not</span>
<span class="sd">            for users to call directly. Without this method, the Lace</span>
<span class="sd">            object cannot be created.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parallel_poly_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">polyline_list</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">polyline</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">polyline_list</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">parallel_poly_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">ParallelPolyline</span><span class="p">(</span>
                        <span class="n">polyline</span><span class="p">,</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">offset</span><span class="p">,</span>
                        <span class="n">lace</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
                        <span class="n">closed</span><span class="o">=</span><span class="n">polyline</span><span class="o">.</span><span class="n">closed</span><span class="p">,</span>
                        <span class="n">dist_tol</span><span class="o">=</span><span class="n">defaults</span><span class="p">[</span><span class="s2">&quot;dist_tol&quot;</span><span class="p">]</span>
                    <span class="p">)</span>
                <span class="p">)</span>

    <span class="c1"># @timing</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_set_overlaps</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Populate the self.overlaps list with Overlap objects. Side</span>
<span class="sd">        effects listed below.</span>

<span class="sd">        Arguments:</span>
<span class="sd">        ----------</span>
<span class="sd">            None</span>

<span class="sd">        Return:</span>
<span class="sd">        --------</span>
<span class="sd">            None</span>

<span class="sd">        Side Effects:</span>
<span class="sd">        -------------</span>
<span class="sd">            * self.overlaps is populated with Overlap objects.</span>
<span class="sd">            * Section objects&#39; overlap attribute is populated with the</span>
<span class="sd">              corresponding Overlap object that they are a part of. Not</span>
<span class="sd">              all sections will have an overlap.</span>

<span class="sd">        Prerequisites:</span>
<span class="sd">        --------------</span>
<span class="sd">            self.polyline and self.parallel_poly_list must be populated.</span>
<span class="sd">            self.main_intersections, self.offset_sections and</span>
<span class="sd">            self.d_intersections must be populated prior to creating</span>
<span class="sd">            the overlaps.</span>

<span class="sd">        Notes:</span>
<span class="sd">        ------</span>
<span class="sd">            This method is called by the Lace constructor.  It is not</span>
<span class="sd">            for users to call directly.</span>
<span class="sd">            Without this method, the Lace object cannot be created.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">section</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_offset_sections</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">section</span><span class="o">.</span><span class="n">is_overlap</span><span class="p">:</span>
                <span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">section</span><span class="o">.</span><span class="n">start</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">section</span><span class="o">.</span><span class="n">end</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">section</span><span class="o">=</span><span class="n">section</span><span class="p">)</span>
        <span class="n">cycles</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">cycle_basis</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">cycle</span> <span class="ow">in</span> <span class="n">cycles</span><span class="p">:</span>
            <span class="n">cycle</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cycle</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">edges</span> <span class="o">=</span> <span class="n">connected_pairs</span><span class="p">(</span><span class="n">cycle</span><span class="p">)</span>
            <span class="n">sections</span> <span class="o">=</span> <span class="p">[</span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">edge</span><span class="p">][</span><span class="s2">&quot;section&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">]</span>
            <span class="n">s_intersections</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">section</span> <span class="ow">in</span> <span class="n">sections</span><span class="p">:</span>
                <span class="n">s_intersections</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">section</span><span class="o">.</span><span class="n">start</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
                <span class="n">s_intersections</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">section</span><span class="o">.</span><span class="n">end</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
            <span class="n">intersections</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">d_intersections</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">s_intersections</span><span class="p">]</span>
            <span class="n">overlap</span> <span class="o">=</span> <span class="n">Overlap</span><span class="p">(</span><span class="n">intersections</span><span class="o">=</span><span class="n">intersections</span><span class="p">,</span> <span class="n">sections</span><span class="o">=</span><span class="n">sections</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">section</span> <span class="ow">in</span> <span class="n">sections</span><span class="p">:</span>
                <span class="n">section</span><span class="o">.</span><span class="n">overlap</span> <span class="o">=</span> <span class="n">overlap</span>
            <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
                <span class="n">section</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">edge</span><span class="p">][</span><span class="s2">&quot;section&quot;</span><span class="p">]</span>
                <span class="n">section</span><span class="o">.</span><span class="n">start</span><span class="o">.</span><span class="n">overlap</span> <span class="o">=</span> <span class="n">overlap</span>
                <span class="n">section</span><span class="o">.</span><span class="n">end</span><span class="o">.</span><span class="n">overlap</span> <span class="o">=</span> <span class="n">overlap</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">overlaps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">overlap</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">overlap</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">overlaps</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">section</span> <span class="ow">in</span> <span class="n">overlap</span><span class="o">.</span><span class="n">sections</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">section</span><span class="o">.</span><span class="n">is_over</span><span class="p">:</span>
                    <span class="n">line_width</span> <span class="o">=</span> <span class="mi">3</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">line_width</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="n">line</span> <span class="o">=</span> <span class="n">Shape</span><span class="p">(</span>
                    <span class="p">[</span><span class="n">section</span><span class="o">.</span><span class="n">start</span><span class="o">.</span><span class="n">point</span><span class="p">,</span> <span class="n">section</span><span class="o">.</span><span class="n">end</span><span class="o">.</span><span class="n">point</span><span class="p">],</span> <span class="n">line_width</span><span class="o">=</span><span class="n">line_width</span>
                <span class="p">)</span>
        <span class="k">for</span> <span class="n">division</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">offset_divisions</span><span class="p">:</span>
            <span class="n">p1</span> <span class="o">=</span> <span class="n">division</span><span class="o">.</span><span class="n">start</span><span class="o">.</span><span class="n">point</span>
            <span class="n">p2</span> <span class="o">=</span> <span class="n">division</span><span class="o">.</span><span class="n">end</span><span class="o">.</span><span class="n">point</span>

<div class="viewcode-block" id="Lace.set_plaits">
<a class="viewcode-back" href="../../../simetri.lace.html#simetri.lace.lace.Lace.set_plaits">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">set_plaits</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Populate the self.plaits list with Plait objects. Plaits are</span>
<span class="sd">        optional for drawing. They form the under/over interlacing. They</span>
<span class="sd">        are created if the &quot;with_plaits&quot; argument is set to be True in</span>
<span class="sd">        the constructor. with_plaits is True by default but this can be</span>
<span class="sd">        changed by setting the auto_plaits value to False in the</span>
<span class="sd">        settings.py This method can be called by the user to create the</span>
<span class="sd">        plaits after the creation of the Lace object if they were not</span>
<span class="sd">        created initally.</span>

<span class="sd">        * Can be called by users.</span>

<span class="sd">        Arguments:</span>
<span class="sd">        ----------</span>
<span class="sd">            None</span>

<span class="sd">        Return:</span>
<span class="sd">        --------</span>
<span class="sd">            None</span>

<span class="sd">        Side Effects:</span>
<span class="sd">        -------------</span>
<span class="sd">            * self.plaits is populated with Plait objects.</span>

<span class="sd">        Prerequisites:</span>
<span class="sd">        --------------</span>
<span class="sd">            self.polyline and self.parallel_poly_list must be populated.</span>
<span class="sd">            self.divisions and self.intersections must be populated.</span>
<span class="sd">            self.overlaps must be populated.</span>

<span class="sd">        Where used:</span>
<span class="sd">        -----------</span>
<span class="sd">            Lace.__init__</span>

<span class="sd">        Notes:</span>
<span class="sd">        ------</span>
<span class="sd">            This method is called by the Lace constructor.  It is not</span>
<span class="sd">            for users to call directly. Without this method, the Lace</span>
<span class="sd">            object cannot be created.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">plaits</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="n">plait_sections</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">division</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_offset_divisions</span><span class="p">():</span>
            <span class="n">merged_sections</span> <span class="o">=</span> <span class="n">division</span><span class="o">.</span><span class="n">_merged_sections</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">merged</span> <span class="ow">in</span> <span class="n">merged_sections</span><span class="p">:</span>
                <span class="n">plait_sections</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">merged</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">merged</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>

        <span class="c1"># connect the open ends of the polyline_shapes</span>
        <span class="k">for</span> <span class="n">ppoly</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parallel_poly_list</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">ppoly</span><span class="o">.</span><span class="n">closed</span><span class="p">:</span>
                <span class="n">polyline1</span> <span class="o">=</span> <span class="n">ppoly</span><span class="o">.</span><span class="n">offset_poly_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">polyline2</span> <span class="o">=</span> <span class="n">ppoly</span><span class="o">.</span><span class="n">offset_poly_list</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">p1_start_x</span> <span class="o">=</span> <span class="n">polyline1</span><span class="o">.</span><span class="n">intersections</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">p1_end_x</span> <span class="o">=</span> <span class="n">polyline1</span><span class="o">.</span><span class="n">intersections</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">p2_start_x</span> <span class="o">=</span> <span class="n">polyline2</span><span class="o">.</span><span class="n">intersections</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">p2_end_x</span> <span class="o">=</span> <span class="n">polyline2</span><span class="o">.</span><span class="n">intersections</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

                <span class="n">plait_sections</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">p1_start_x</span><span class="p">,</span> <span class="n">p2_start_x</span><span class="p">))</span>
                <span class="n">plait_sections</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">p1_end_x</span><span class="p">,</span> <span class="n">p2_end_x</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">sec</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_offset_sections</span><span class="p">():</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">sec</span><span class="o">.</span><span class="n">is_over</span> <span class="ow">and</span> <span class="n">sec</span><span class="o">.</span><span class="n">is_overlap</span><span class="p">:</span>
                <span class="n">plait_sections</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">sec</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">sec</span><span class="o">.</span><span class="n">end</span><span class="p">))</span>

        <span class="n">graph_edges</span> <span class="o">=</span> <span class="p">[(</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">id</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">plait_sections</span><span class="p">]</span>
        <span class="n">cycles</span> <span class="o">=</span> <span class="n">get_cycles</span><span class="p">(</span><span class="n">graph_edges</span><span class="p">)</span>
        <span class="n">plaits</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">cycle</span> <span class="ow">in</span> <span class="n">cycles</span><span class="p">:</span>
            <span class="n">cycle</span> <span class="o">=</span> <span class="n">connected_pairs</span><span class="p">(</span><span class="n">cycle</span><span class="p">)</span>
            <span class="n">dup</span> <span class="o">=</span> <span class="n">cycle</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
            <span class="n">plait</span> <span class="o">=</span> <span class="p">[</span><span class="n">cycle</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">cycle</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]]</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cycle</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">last</span> <span class="o">=</span> <span class="n">plait</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="n">dup</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">last</span><span class="p">:</span>
                        <span class="n">plait</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                        <span class="n">dup</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>
                        <span class="k">break</span>
                    <span class="k">if</span> <span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">last</span><span class="p">:</span>
                        <span class="n">plait</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                        <span class="n">dup</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>
                        <span class="k">break</span>
            <span class="n">plaits</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">plait</span><span class="p">)</span>
            <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">d_x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">d_intersections</span>
        <span class="k">for</span> <span class="n">plait</span> <span class="ow">in</span> <span class="n">plaits</span><span class="p">:</span>
            <span class="n">intersections</span> <span class="o">=</span> <span class="p">[</span><span class="n">d_x</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">plait</span><span class="p">]</span>
            <span class="n">vertices</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">point</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">intersections</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">right_handed</span><span class="p">(</span><span class="n">vertices</span><span class="p">):</span>
                <span class="n">vertices</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
                <span class="n">plait</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="n">Shape</span><span class="p">(</span><span class="n">vertices</span><span class="p">)</span>
            <span class="n">shape</span><span class="o">.</span><span class="n">intersections</span> <span class="o">=</span> <span class="n">intersections</span>
            <span class="n">shape</span><span class="o">.</span><span class="n">fill_color</span> <span class="o">=</span> <span class="n">colors</span><span class="o">.</span><span class="n">gold</span>
            <span class="n">shape</span><span class="o">.</span><span class="n">inner_lines</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">shape</span><span class="o">.</span><span class="n">subtype</span> <span class="o">=</span> <span class="n">Types</span><span class="o">.</span><span class="n">PLAIT</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">plaits</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span></div>


    <span class="c1"># @timing</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_set_intersections</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute all intersection points (by calling all_intersections)</span>
<span class="sd">        among the divisions of the polylines (both main and offset).</span>
<span class="sd">        Populate the self.main_intersections and</span>
<span class="sd">        self.offset_intersections lists with Intersection objects. This</span>
<span class="sd">        method is called by the Lace constructor and customized to be</span>
<span class="sd">        used with Lace objects only. Without this method, the Lace</span>
<span class="sd">        object cannot be created.</span>

<span class="sd">        * Internal use only!</span>

<span class="sd">        Arguments:</span>
<span class="sd">        ----------</span>
<span class="sd">            None</span>

<span class="sd">        Return:</span>
<span class="sd">        --------</span>
<span class="sd">            None</span>

<span class="sd">        Side Effects:</span>
<span class="sd">        -------------</span>
<span class="sd">            * self.main_intersections are populated.</span>
<span class="sd">            * self.offset_intersections are populated.</span>
<span class="sd">            * &quot;sections&quot; attribute of the divisions are populated.</span>
<span class="sd">            * &quot;is_overlap&quot; attribute of the sections are populated.</span>
<span class="sd">            * &quot;intersections&quot; attribute of the divisions are populated.</span>
<span class="sd">            * &quot;endpoint&quot; attribute of the intersections are populated.</span>

<span class="sd">        Where used:</span>
<span class="sd">        -----------</span>
<span class="sd">            Lace.__init__</span>

<span class="sd">        Prerequisites:</span>
<span class="sd">        --------------</span>
<span class="sd">            * self.main_divisions must be populated.</span>
<span class="sd">            * self.offset_divisions must be populated.</span>
<span class="sd">            * Two endpoint intersections of the divisions must be set.</span>

<span class="sd">        Notes:</span>
<span class="sd">        ------</span>
<span class="sd">            This method is called by the Lace constructor.  It is not</span>
<span class="sd">            for users to call directly. Without this method, the Lace</span>
<span class="sd">            object cannot be created.</span>
<span class="sd">            Works only for regular under/over interlacing.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># set intersections for the main polylines</span>
        <span class="n">main_divisions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">main_divisions</span>
        <span class="n">offset_divisions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">offset_divisions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">main_intersections</span> <span class="o">=</span> <span class="n">all_intersections</span><span class="p">(</span>
            <span class="n">main_divisions</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">d_intersections</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">d_connections</span>
        <span class="p">)</span>

        <span class="c1"># set sections for the main divisions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">main_sections</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">division</span> <span class="ow">in</span> <span class="n">main_divisions</span><span class="p">:</span>
            <span class="n">division</span><span class="o">.</span><span class="n">intersections</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">endpoint</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">division</span><span class="o">.</span><span class="n">intersections</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">endpoint</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">segments</span> <span class="o">=</span> <span class="n">connected_pairs</span><span class="p">(</span><span class="n">division</span><span class="o">.</span><span class="n">intersections</span><span class="p">)</span>
            <span class="n">division</span><span class="o">.</span><span class="n">sections</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">segment</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">segments</span><span class="p">):</span>
                <span class="n">section</span> <span class="o">=</span> <span class="n">Section</span><span class="p">(</span><span class="o">*</span><span class="n">segment</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">section</span><span class="o">.</span><span class="n">is_overlap</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">division</span><span class="o">.</span><span class="n">sections</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">section</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">main_sections</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">section</span><span class="p">)</span>
        <span class="c1"># set intersections for the offset polylines</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">offset_intersections</span> <span class="o">=</span> <span class="n">all_intersections</span><span class="p">(</span>
            <span class="n">offset_divisions</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">d_intersections</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">d_connections</span>
        <span class="p">)</span>
        <span class="c1"># set sections for the offset divisions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">offset_sections</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">division</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">offset_divisions</span><span class="p">):</span>
            <span class="n">division</span><span class="o">.</span><span class="n">intersections</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">endpoint</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">division</span><span class="o">.</span><span class="n">intersections</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">endpoint</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">lines</span> <span class="o">=</span> <span class="n">connected_pairs</span><span class="p">(</span><span class="n">division</span><span class="o">.</span><span class="n">intersections</span><span class="p">)</span>
            <span class="n">division</span><span class="o">.</span><span class="n">sections</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">line</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">lines</span><span class="p">):</span>
                <span class="n">section</span> <span class="o">=</span> <span class="n">Section</span><span class="p">(</span><span class="o">*</span><span class="n">line</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">j</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">section</span><span class="o">.</span><span class="n">is_overlap</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">division</span><span class="o">.</span><span class="n">sections</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">section</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">offset_sections</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">section</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_all_polygons</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">polylines</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a list of polygons from a list of lists of points.</span>
<span class="sd">        polylines: [[(x1, y1), (x2, y2)], [(x3, y3), (x4, y4)], ...]</span>
<span class="sd">        return [[(x1, y1), (x2, y2), (x3, y3), ...], ...]</span>

<span class="sd">        Args:</span>
<span class="sd">            polylines (list): List of lists of points.</span>
<span class="sd">            rtol (float, optional): Relative tolerance. Defaults to None.</span>

<span class="sd">        Returns:</span>
<span class="sd">            list: List of polygons.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">rtol</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">rtol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rtol</span>
        <span class="k">return</span> <span class="n">get_polygons</span><span class="p">(</span><span class="n">polylines</span><span class="p">,</span> <span class="n">rtol</span><span class="p">)</span>

    <span class="c1"># @timing</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_set_over_under</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">next_poly</span><span class="p">(</span><span class="n">exclude</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">ppoly</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parallel_poly_list</span><span class="p">:</span>
                <span class="n">poly1</span><span class="p">,</span> <span class="n">poly2</span> <span class="o">=</span> <span class="n">ppoly</span><span class="o">.</span><span class="n">offset_poly_list</span>
                <span class="k">if</span> <span class="n">poly1</span> <span class="ow">in</span> <span class="n">exclude</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">ind</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">for</span> <span class="n">sec</span> <span class="ow">in</span> <span class="n">poly1</span><span class="o">.</span><span class="n">iter_sections</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">sec</span><span class="o">.</span><span class="n">is_overlap</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">sec</span><span class="o">.</span><span class="n">overlap</span><span class="o">.</span><span class="n">drawable</span> <span class="ow">and</span> <span class="n">sec</span><span class="o">.</span><span class="n">overlap</span><span class="o">.</span><span class="n">visited</span><span class="p">:</span>
                            <span class="n">even_odd</span> <span class="o">=</span> <span class="n">ind</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span>
                            <span class="k">return</span> <span class="p">(</span><span class="n">poly1</span><span class="p">,</span> <span class="n">poly2</span><span class="p">,</span> <span class="n">even_odd</span><span class="p">)</span>
                        <span class="n">ind</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">return</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">ppoly</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parallel_poly_list</span><span class="p">:</span>
            <span class="n">poly1</span><span class="p">,</span> <span class="n">poly2</span> <span class="o">=</span> <span class="n">ppoly</span><span class="o">.</span><span class="n">offset_poly_list</span>
            <span class="n">exclude</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">even_odd</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">while</span> <span class="n">poly1</span><span class="p">:</span>
                <span class="n">ind</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">division</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">poly1</span><span class="o">.</span><span class="n">divisions</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">section</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">division</span><span class="o">.</span><span class="n">sections</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">section</span><span class="o">.</span><span class="n">is_overlap</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">section</span><span class="o">.</span><span class="n">overlap</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                                <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
                                    <span class="s2">&quot;Overlap section in the lace has no &quot;</span>
                                    <span class="s2">&quot;overlap object.</span><span class="se">\n</span><span class="s2">&quot;</span>
                                    <span class="s2">&quot;Try different offset value and/or &quot;</span>
                                    <span class="s2">&quot;tolerance.&quot;</span>
                                <span class="p">)</span>
                                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
                            <span class="n">section</span><span class="o">.</span><span class="n">overlap</span><span class="o">.</span><span class="n">visited</span> <span class="o">=</span> <span class="kc">True</span>
                            <span class="k">if</span> <span class="n">ind</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="n">even_odd</span><span class="p">:</span>
                                <span class="k">if</span> <span class="n">section</span><span class="o">.</span><span class="n">overlap</span><span class="o">.</span><span class="n">drawable</span><span class="p">:</span>
                                    <span class="n">section</span><span class="o">.</span><span class="n">overlap</span><span class="o">.</span><span class="n">drawable</span> <span class="o">=</span> <span class="kc">False</span>
                                    <span class="n">section</span><span class="o">.</span><span class="n">is_over</span> <span class="o">=</span> <span class="kc">True</span>
                                    <span class="n">section2</span> <span class="o">=</span> <span class="n">poly2</span><span class="o">.</span><span class="n">divisions</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">sections</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                                    <span class="n">section2</span><span class="o">.</span><span class="n">is_over</span> <span class="o">=</span> <span class="kc">True</span>
                            <span class="n">ind</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">exclude</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">poly1</span><span class="p">,</span> <span class="n">poly2</span><span class="p">])</span>
                <span class="n">poly1</span><span class="p">,</span> <span class="n">poly2</span><span class="p">,</span> <span class="n">even_odd</span> <span class="o">=</span> <span class="n">next_poly</span><span class="p">(</span><span class="n">exclude</span><span class="p">)</span>

<div class="viewcode-block" id="Lace.fragment_edge_graph">
<a class="viewcode-back" href="../../../simetri.lace.html#simetri.lace.lace.Lace.fragment_edge_graph">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">fragment_edge_graph</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a networkx graph of the connected fragments.</span>
<span class="sd">        If two fragments have a &quot;common&quot; division then they are connected.</span>

<span class="sd">        Returns:</span>
<span class="sd">            nx.Graph: Graph of connected fragments.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
        <span class="n">fragments</span> <span class="o">=</span> <span class="p">[(</span><span class="n">f</span><span class="o">.</span><span class="n">area</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fragments</span><span class="p">]</span>
        <span class="n">fragments</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">fragment</span> <span class="ow">in</span> <span class="p">[</span><span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">fragments</span><span class="p">[</span><span class="mi">1</span><span class="p">:]]:</span>
            <span class="k">for</span> <span class="n">division</span> <span class="ow">in</span> <span class="n">fragment</span><span class="o">.</span><span class="n">divisions</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">division</span><span class="o">.</span><span class="n">twin</span> <span class="ow">and</span> <span class="n">division</span><span class="o">.</span><span class="n">twin</span><span class="o">.</span><span class="n">fragment</span><span class="p">:</span>
                    <span class="n">fragment2</span> <span class="o">=</span> <span class="n">division</span><span class="o">.</span><span class="n">twin</span><span class="o">.</span><span class="n">fragment</span>
                    <span class="n">G</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">fragment</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">fragment</span><span class="o">=</span><span class="n">fragment</span><span class="p">)</span>
                    <span class="n">G</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">fragment2</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">fragment</span><span class="o">=</span><span class="n">fragment2</span><span class="p">)</span>
                    <span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">fragment</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">fragment2</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">edge</span><span class="o">=</span><span class="n">division</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">G</span></div>


<div class="viewcode-block" id="Lace.fragment_vertex_graph">
<a class="viewcode-back" href="../../../simetri.lace.html#simetri.lace.lace.Lace.fragment_vertex_graph">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">fragment_vertex_graph</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a networkx graph of the connected fragments.</span>
<span class="sd">        If two fragments have a &quot;common&quot; vertex then they are connected.</span>

<span class="sd">        Returns:</span>
<span class="sd">            nx.Graph: Graph of connected fragments.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">get_neighbours</span><span class="p">(</span><span class="n">intersection</span><span class="p">):</span>
            <span class="n">division</span> <span class="o">=</span> <span class="n">intersection</span><span class="o">.</span><span class="n">division</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">division</span><span class="o">.</span><span class="n">next</span><span class="o">.</span><span class="n">twin</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>
            <span class="n">fragments</span> <span class="o">=</span> <span class="p">[</span><span class="n">division</span><span class="o">.</span><span class="n">fragment</span><span class="p">]</span>
            <span class="n">start_division_id</span> <span class="o">=</span> <span class="n">division</span><span class="o">.</span><span class="n">id</span>
            <span class="k">if</span> <span class="n">division</span><span class="o">.</span><span class="n">next</span><span class="o">.</span><span class="n">twin</span><span class="p">:</span>
                <span class="n">twin_id</span> <span class="o">=</span> <span class="n">division</span><span class="o">.</span><span class="n">next</span><span class="o">.</span><span class="n">twin</span><span class="o">.</span><span class="n">id</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>
            <span class="k">while</span> <span class="n">twin_id</span> <span class="o">!=</span> <span class="n">start_division_id</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">division</span><span class="o">.</span><span class="n">next</span><span class="o">.</span><span class="n">twin</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">division</span><span class="o">.</span><span class="n">fragment</span><span class="o">.</span><span class="n">id</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">id</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">fragments</span><span class="p">]:</span>
                        <span class="n">fragments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">division</span><span class="o">.</span><span class="n">fragment</span><span class="p">)</span>
                    <span class="n">twin_id</span> <span class="o">=</span> <span class="n">division</span><span class="o">.</span><span class="n">next</span><span class="o">.</span><span class="n">twin</span><span class="o">.</span><span class="n">id</span>
                    <span class="n">division</span> <span class="o">=</span> <span class="n">division</span><span class="o">.</span><span class="n">next</span><span class="o">.</span><span class="n">twin</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">division</span><span class="o">.</span><span class="n">next</span><span class="o">.</span><span class="n">fragment</span><span class="o">.</span><span class="n">id</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">id</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">fragments</span><span class="p">]:</span>
                        <span class="n">fragments</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">division</span><span class="o">.</span><span class="n">next</span><span class="o">.</span><span class="n">fragment</span><span class="p">)</span>
                    <span class="k">break</span>

            <span class="k">return</span> <span class="n">fragments</span>

        <span class="n">neighbours</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">fragment</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">fragments</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">intersection</span> <span class="ow">in</span> <span class="n">fragment</span><span class="o">.</span><span class="n">intersections</span><span class="p">:</span>
                <span class="n">neighbours</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">get_neighbours</span><span class="p">(</span><span class="n">intersection</span><span class="p">))</span>
        <span class="n">G</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fragment_edge_graph</span><span class="p">()</span>
        <span class="n">G2</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">neighbours</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">n</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="n">combinations</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
                        <span class="n">ids</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="n">x</span><span class="o">.</span><span class="n">id</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">pair</span><span class="p">])</span>
                        <span class="k">if</span> <span class="n">ids</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">:</span>
                            <span class="n">G2</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">ids</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">fragment</span><span class="o">=</span><span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                            <span class="n">G2</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">ids</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">fragment</span><span class="o">=</span><span class="n">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                            <span class="n">G2</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="o">*</span><span class="n">ids</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">G2</span></div>
</div>



<div class="viewcode-block" id="all_intersections">
<a class="viewcode-back" href="../../../simetri.lace.html#simetri.lace.lace.all_intersections">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">all_intersections</span><span class="p">(</span>
    <span class="n">division_list</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Division</span><span class="p">],</span>
    <span class="n">d_intersections</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Intersection</span><span class="p">],</span>
    <span class="n">d_connections</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">frozenset</span><span class="p">,</span> <span class="n">Intersection</span><span class="p">],</span>
    <span class="n">loom</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">Intersection</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find all intersections of the given divisions. Sweep-line algorithm</span>
<span class="sd">    without a self-balancing tree. Instead of a self-balancing tree,</span>
<span class="sd">    it uses a numpy array to sort and filter the divisions. For the</span>
<span class="sd">    number of divisions that are commonly needed in a lace, this is</span>
<span class="sd">    sufficiently fast. It is also more robust and much easier to</span>
<span class="sd">    understand and debug. Tested with tens of thousands of divisions but</span>
<span class="sd">    not millions. The book has a section on this algorithm.</span>
<span class="sd">    simetri.geometry.py has another version (called</span>
<span class="sd">    all_intersections) for finding intersections among a given</span>
<span class="sd">    list of divisions.</span>

<span class="sd">    Arguments:</span>
<span class="sd">    ----------</span>
<span class="sd">        division_list: list of Division objects.</span>

<span class="sd">    Side Effects:</span>
<span class="sd">    -------------</span>
<span class="sd">        * Modifies the given division objects (in the division_list) in place</span>
<span class="sd">            by adding the intersections to the divisions&#39; &quot;intersections&quot;</span>
<span class="sd">            attribute.</span>
<span class="sd">        * Updates the d_intersections</span>
<span class="sd">        * Updates the d_connections</span>

<span class="sd">    Return:</span>
<span class="sd">    --------</span>
<span class="sd">        A list of all intersection objects among the given division</span>
<span class="sd">        list.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># register fake intersections at the endpoints of the open lines</span>
    <span class="k">for</span> <span class="n">division</span> <span class="ow">in</span> <span class="n">division_list</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">division</span><span class="o">.</span><span class="n">intersections</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">division</span><span class="o">.</span><span class="n">intersections</span><span class="p">:</span>
                <span class="n">d_intersections</span><span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">id</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span>

    <span class="c1"># All objects are assigned an integer id attribute when they are created</span>
    <span class="n">division_array</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span>
        <span class="p">[</span><span class="n">flatten</span><span class="p">(</span><span class="n">division</span><span class="o">.</span><span class="n">vertices</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="n">division</span><span class="o">.</span><span class="n">id</span><span class="p">]</span> <span class="k">for</span> <span class="n">division</span> <span class="ow">in</span> <span class="n">division_list</span><span class="p">]</span>
    <span class="p">)</span>
    <span class="n">n_divisions</span> <span class="o">=</span> <span class="n">division_array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># number of divisions</span>
    <span class="c1"># precompute the min and max x and y values for each division</span>
    <span class="c1"># these will be used with the sweep line algorithm</span>
    <span class="n">xmin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">division_array</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">division_array</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
        <span class="n">n_divisions</span><span class="p">,</span> <span class="mi">1</span>
    <span class="p">)</span>
    <span class="n">xmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">division_array</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">division_array</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
        <span class="n">n_divisions</span><span class="p">,</span> <span class="mi">1</span>
    <span class="p">)</span>
    <span class="n">ymin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">division_array</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">division_array</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
        <span class="n">n_divisions</span><span class="p">,</span> <span class="mi">1</span>
    <span class="p">)</span>
    <span class="n">ymax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">division_array</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">division_array</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
        <span class="n">n_divisions</span><span class="p">,</span> <span class="mi">1</span>
    <span class="p">)</span>
    <span class="n">division_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">division_array</span><span class="p">,</span> <span class="n">xmin</span><span class="p">,</span> <span class="n">ymin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">,</span> <span class="n">ymax</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">d_divisions</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">division</span> <span class="ow">in</span> <span class="n">division_list</span><span class="p">:</span>
        <span class="n">d_divisions</span><span class="p">[</span><span class="n">division</span><span class="o">.</span><span class="n">id</span><span class="p">]</span> <span class="o">=</span> <span class="n">division</span>
    <span class="n">i_id</span><span class="p">,</span> <span class="n">i_xmin</span><span class="p">,</span> <span class="n">i_ymin</span><span class="p">,</span> <span class="n">i_xmax</span><span class="p">,</span> <span class="n">i_ymax</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">9</span><span class="p">)</span>  <span class="c1"># column indices</span>
    <span class="c1"># sort by xmin values</span>
    <span class="n">division_array</span> <span class="o">=</span> <span class="n">division_array</span><span class="p">[</span><span class="n">division_array</span><span class="p">[:,</span> <span class="n">i_xmin</span><span class="p">]</span><span class="o">.</span><span class="n">argsort</span><span class="p">()]</span>
    <span class="n">intersections</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_divisions</span><span class="p">):</span>
        <span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">y2</span><span class="p">,</span> <span class="n">id1</span><span class="p">,</span> <span class="n">sl_xmin</span><span class="p">,</span> <span class="n">sl_ymin</span><span class="p">,</span> <span class="n">sl_xmax</span><span class="p">,</span> <span class="n">sl_ymax</span> <span class="o">=</span> <span class="n">division_array</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">division1_vertices</span> <span class="o">=</span> <span class="p">[</span><span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">y2</span><span class="p">]</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>  <span class="c1"># search should start from the next division</span>
        <span class="c1"># filter the array by checking if the divisions&#39; bounding-boxes are</span>
        <span class="c1"># overlapping with the bounding-box of the current division</span>
        <span class="n">candidates</span> <span class="o">=</span> <span class="n">division_array</span><span class="p">[</span><span class="n">start</span><span class="p">:,</span> <span class="p">:][</span>
            <span class="p">(</span>
                <span class="p">(</span>
                    <span class="p">(</span><span class="n">division_array</span><span class="p">[</span><span class="n">start</span><span class="p">:,</span> <span class="n">i_xmax</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">sl_xmin</span><span class="p">)</span>
                    <span class="o">&amp;</span> <span class="p">(</span><span class="n">division_array</span><span class="p">[</span><span class="n">start</span><span class="p">:,</span> <span class="n">i_xmin</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">sl_xmax</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="o">&amp;</span> <span class="p">(</span>
                    <span class="p">(</span><span class="n">division_array</span><span class="p">[</span><span class="n">start</span><span class="p">:,</span> <span class="n">i_ymax</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">sl_ymin</span><span class="p">)</span>
                    <span class="o">&amp;</span> <span class="p">(</span><span class="n">division_array</span><span class="p">[</span><span class="n">start</span><span class="p">:,</span> <span class="n">i_ymin</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">sl_ymax</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="p">]</span>
        <span class="k">for</span> <span class="n">candid</span> <span class="ow">in</span> <span class="n">candidates</span><span class="p">:</span>
            <span class="n">id2</span> <span class="o">=</span> <span class="n">candid</span><span class="p">[</span><span class="n">i_id</span><span class="p">]</span>
            <span class="n">division2_vertices</span> <span class="o">=</span> <span class="n">candid</span><span class="p">[:</span><span class="mi">4</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">loom</span><span class="p">:</span>
                <span class="n">x1</span><span class="p">,</span> <span class="n">y1</span> <span class="o">=</span> <span class="n">division1_vertices</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>
                <span class="n">x2</span><span class="p">,</span> <span class="n">y2</span> <span class="o">=</span> <span class="n">division2_vertices</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">x1</span> <span class="o">==</span> <span class="n">x2</span> <span class="ow">or</span> <span class="n">y1</span> <span class="o">==</span> <span class="n">y2</span><span class="p">:</span>
                    <span class="k">continue</span>
            <span class="n">connection_type</span><span class="p">,</span> <span class="n">x_point</span> <span class="o">=</span> <span class="n">intersection2</span><span class="p">(</span>
                <span class="o">*</span><span class="n">division1_vertices</span><span class="p">,</span> <span class="o">*</span><span class="n">division2_vertices</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">connection_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span>
                <span class="n">Connection</span><span class="o">.</span><span class="n">DISJOINT</span><span class="p">,</span>
                <span class="n">Connection</span><span class="o">.</span><span class="n">NONE</span><span class="p">,</span>
                <span class="n">Connection</span><span class="o">.</span><span class="n">PARALLEL</span><span class="p">,</span>
            <span class="p">]:</span>
                <span class="n">division1</span><span class="p">,</span> <span class="n">division2</span> <span class="o">=</span> <span class="n">d_divisions</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">id1</span><span class="p">)],</span> <span class="n">d_divisions</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">id2</span><span class="p">)]</span>
                <span class="n">x_point__e1_2</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">((</span><span class="n">division1</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">division2</span><span class="o">.</span><span class="n">id</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">x_point__e1_2</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">d_connections</span><span class="p">:</span>
                    <span class="n">inters_obj</span> <span class="o">=</span> <span class="n">Intersection</span><span class="p">(</span><span class="n">x_point</span><span class="p">,</span> <span class="n">division1</span><span class="p">,</span> <span class="n">division2</span><span class="p">)</span>
                    <span class="n">d_intersections</span><span class="p">[</span><span class="n">inters_obj</span><span class="o">.</span><span class="n">id</span><span class="p">]</span> <span class="o">=</span> <span class="n">inters_obj</span>
                    <span class="n">d_connections</span><span class="p">[</span><span class="n">x_point__e1_2</span><span class="p">]</span> <span class="o">=</span> <span class="n">inters_obj</span>
                    <span class="n">division1</span><span class="o">.</span><span class="n">intersections</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">inters_obj</span><span class="p">)</span>
                    <span class="n">division2</span><span class="o">.</span><span class="n">intersections</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">inters_obj</span><span class="p">)</span>
                    <span class="n">intersections</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">inters_obj</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">division</span> <span class="ow">in</span> <span class="n">division_list</span><span class="p">:</span>
        <span class="n">division</span><span class="o">.</span><span class="n">_sort_intersections</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">intersections</span></div>



<div class="viewcode-block" id="merge_nodes">
<a class="viewcode-back" href="../../../simetri.lace.html#simetri.lace.lace.merge_nodes">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">merge_nodes</span><span class="p">(</span>
    <span class="n">division_list</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Division</span><span class="p">],</span>
    <span class="n">d_intersections</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Intersection</span><span class="p">],</span>
    <span class="n">d_connections</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">frozenset</span><span class="p">,</span> <span class="n">Intersection</span><span class="p">],</span>
    <span class="n">loom</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">Intersection</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find all intersections of the given divisions. Sweep-line algorithm</span>
<span class="sd">    without a self-balancing tree. Instead of a self-balancing tree,</span>
<span class="sd">    it uses a numpy array to sort and filter the divisions. For the</span>
<span class="sd">    number of divisions that are commonly needed in a lace, this is</span>
<span class="sd">    sufficiently fast. It is also more robust and much easier to</span>
<span class="sd">    understand and debug. Tested with tens of thousands of divisions but</span>
<span class="sd">    not millions. The book has a section on this algorithm.</span>
<span class="sd">    simetri.geometry.py has another version (called</span>
<span class="sd">    all_intersections) for finding intersections among a given</span>
<span class="sd">    list of divisions.</span>

<span class="sd">    Arguments:</span>
<span class="sd">    ----------</span>
<span class="sd">        division_list: list of division objects.</span>

<span class="sd">    Side Effects:</span>
<span class="sd">    -------------</span>
<span class="sd">        * Modifies the given division objects (in the division_list) in place</span>
<span class="sd">            by adding the intersections to the divisions&#39; &quot;intersections&quot;</span>
<span class="sd">            attribute.</span>
<span class="sd">        * Updates the d_intersections</span>
<span class="sd">        * Updates the d_connections</span>

<span class="sd">    Return:</span>
<span class="sd">    --------</span>
<span class="sd">        A list of all intersection objects among the given division</span>
<span class="sd">        list.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># register fake intersections at the endpoints of the open lines</span>
    <span class="k">for</span> <span class="n">division</span> <span class="ow">in</span> <span class="n">division_list</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">division</span><span class="o">.</span><span class="n">intersections</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">division</span><span class="o">.</span><span class="n">intersections</span><span class="p">:</span>
                <span class="n">d_intersections</span><span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">id</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span>

    <span class="c1"># All objects are assigned an integer id attribute when they are created</span>
    <span class="n">division_array</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span>
        <span class="p">[</span><span class="n">flatten</span><span class="p">(</span><span class="n">division</span><span class="o">.</span><span class="n">vertices</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="n">division</span><span class="o">.</span><span class="n">id</span><span class="p">]</span> <span class="k">for</span> <span class="n">division</span> <span class="ow">in</span> <span class="n">division_list</span><span class="p">]</span>
    <span class="p">)</span>
    <span class="n">n_divisions</span> <span class="o">=</span> <span class="n">division_array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># number of divisions</span>
    <span class="c1"># precompute the min and max x and y values for each division</span>
    <span class="c1"># these will be used with the sweep line algorithm</span>
    <span class="n">xmin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">division_array</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">division_array</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
        <span class="n">n_divisions</span><span class="p">,</span> <span class="mi">1</span>
    <span class="p">)</span>
    <span class="n">xmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">division_array</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">division_array</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
        <span class="n">n_divisions</span><span class="p">,</span> <span class="mi">1</span>
    <span class="p">)</span>
    <span class="n">ymin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">division_array</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">division_array</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
        <span class="n">n_divisions</span><span class="p">,</span> <span class="mi">1</span>
    <span class="p">)</span>
    <span class="n">ymax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">division_array</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">division_array</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">])</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
        <span class="n">n_divisions</span><span class="p">,</span> <span class="mi">1</span>
    <span class="p">)</span>
    <span class="n">division_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">division_array</span><span class="p">,</span> <span class="n">xmin</span><span class="p">,</span> <span class="n">ymin</span><span class="p">,</span> <span class="n">xmax</span><span class="p">,</span> <span class="n">ymax</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">d_divisions</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">division</span> <span class="ow">in</span> <span class="n">division_list</span><span class="p">:</span>
        <span class="n">d_divisions</span><span class="p">[</span><span class="n">division</span><span class="o">.</span><span class="n">id</span><span class="p">]</span> <span class="o">=</span> <span class="n">division</span>
    <span class="n">i_id</span><span class="p">,</span> <span class="n">i_xmin</span><span class="p">,</span> <span class="n">i_ymin</span><span class="p">,</span> <span class="n">i_xmax</span><span class="p">,</span> <span class="n">i_ymax</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">9</span><span class="p">)</span>  <span class="c1"># column indices</span>
    <span class="c1"># sort by xmin values</span>
    <span class="n">division_array</span> <span class="o">=</span> <span class="n">division_array</span><span class="p">[</span><span class="n">division_array</span><span class="p">[:,</span> <span class="n">i_xmin</span><span class="p">]</span><span class="o">.</span><span class="n">argsort</span><span class="p">()]</span>
    <span class="n">intersections</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_divisions</span><span class="p">):</span>
        <span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">y2</span><span class="p">,</span> <span class="n">id1</span><span class="p">,</span> <span class="n">sl_xmin</span><span class="p">,</span> <span class="n">sl_ymin</span><span class="p">,</span> <span class="n">sl_xmax</span><span class="p">,</span> <span class="n">sl_ymax</span> <span class="o">=</span> <span class="n">division_array</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">division1_vertices</span> <span class="o">=</span> <span class="p">[</span><span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">y2</span><span class="p">]</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>  <span class="c1"># search should start from the next division</span>
        <span class="c1"># filter the array by checking if the divisions&#39; bounding-boxes are</span>
        <span class="c1"># overlapping with the bounding-box of the current division</span>
        <span class="n">candidates</span> <span class="o">=</span> <span class="n">division_array</span><span class="p">[</span><span class="n">start</span><span class="p">:,</span> <span class="p">:][</span>
            <span class="p">(</span>
                <span class="p">(</span>
                    <span class="p">(</span><span class="n">division_array</span><span class="p">[</span><span class="n">start</span><span class="p">:,</span> <span class="n">i_xmax</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">sl_xmin</span><span class="p">)</span>
                    <span class="o">&amp;</span> <span class="p">(</span><span class="n">division_array</span><span class="p">[</span><span class="n">start</span><span class="p">:,</span> <span class="n">i_xmin</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">sl_xmax</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="o">&amp;</span> <span class="p">(</span>
                    <span class="p">(</span><span class="n">division_array</span><span class="p">[</span><span class="n">start</span><span class="p">:,</span> <span class="n">i_ymax</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">sl_ymin</span><span class="p">)</span>
                    <span class="o">&amp;</span> <span class="p">(</span><span class="n">division_array</span><span class="p">[</span><span class="n">start</span><span class="p">:,</span> <span class="n">i_ymin</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">sl_ymax</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="p">]</span>
        <span class="k">for</span> <span class="n">candid</span> <span class="ow">in</span> <span class="n">candidates</span><span class="p">:</span>
            <span class="n">id2</span> <span class="o">=</span> <span class="n">candid</span><span class="p">[</span><span class="n">i_id</span><span class="p">]</span>
            <span class="n">division2_vertices</span> <span class="o">=</span> <span class="n">candid</span><span class="p">[:</span><span class="mi">4</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">loom</span><span class="p">:</span>
                <span class="n">x1</span><span class="p">,</span> <span class="n">y1</span> <span class="o">=</span> <span class="n">division1_vertices</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>
                <span class="n">x2</span><span class="p">,</span> <span class="n">y2</span> <span class="o">=</span> <span class="n">division2_vertices</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">x1</span> <span class="o">==</span> <span class="n">x2</span> <span class="ow">or</span> <span class="n">y1</span> <span class="o">==</span> <span class="n">y2</span><span class="p">:</span>
                    <span class="k">continue</span>
            <span class="n">connection_type</span><span class="p">,</span> <span class="n">x_point</span> <span class="o">=</span> <span class="n">intersection2</span><span class="p">(</span>
                <span class="o">*</span><span class="n">division1_vertices</span><span class="p">,</span> <span class="o">*</span><span class="n">division2_vertices</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="n">connection_type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span>
                <span class="n">Connection</span><span class="o">.</span><span class="n">DISJOINT</span><span class="p">,</span>
                <span class="n">Connection</span><span class="o">.</span><span class="n">NONE</span><span class="p">,</span>
                <span class="n">Connection</span><span class="o">.</span><span class="n">PARALLEL</span><span class="p">,</span>
            <span class="p">]:</span>
                <span class="n">division1</span><span class="p">,</span> <span class="n">division2</span> <span class="o">=</span> <span class="n">d_divisions</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">id1</span><span class="p">)],</span> <span class="n">d_divisions</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">id2</span><span class="p">)]</span>
                <span class="n">x_point__e1_2</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">((</span><span class="n">division1</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">division2</span><span class="o">.</span><span class="n">id</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">x_point__e1_2</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">d_connections</span><span class="p">:</span>
                    <span class="n">inters_obj</span> <span class="o">=</span> <span class="n">Intersection</span><span class="p">(</span><span class="n">x_point</span><span class="p">,</span> <span class="n">division1</span><span class="p">,</span> <span class="n">division2</span><span class="p">)</span>
                    <span class="n">d_intersections</span><span class="p">[</span><span class="n">inters_obj</span><span class="o">.</span><span class="n">id</span><span class="p">]</span> <span class="o">=</span> <span class="n">inters_obj</span>
                    <span class="n">d_connections</span><span class="p">[</span><span class="n">x_point__e1_2</span><span class="p">]</span> <span class="o">=</span> <span class="n">inters_obj</span>
                    <span class="n">division1</span><span class="o">.</span><span class="n">intersections</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">inters_obj</span><span class="p">)</span>
                    <span class="n">division2</span><span class="o">.</span><span class="n">intersections</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">inters_obj</span><span class="p">)</span>
                    <span class="n">intersections</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">inters_obj</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">division</span> <span class="ow">in</span> <span class="n">division_list</span><span class="p">:</span>
        <span class="n">division</span><span class="o">.</span><span class="n">_sort_intersections</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">intersections</span></div>

</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../index.html">simetri.graphics</a></h1>









<search id="searchbox" style="display: none" role="search">
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false" placeholder="Search"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script><h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">API Reference:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../modules.html">src</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../index.html">Documentation overview</a><ul>
  <li><a href="../../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2025, Fahri Basegmez.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 8.1.3</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 1.0.0</a>
      
    </div>

    

    
  </body>
</html>